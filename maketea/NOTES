MakeTea takes in a grammar, and generates:

 - A C++ class structure that represents the AST corresponding to the
   grammar. The grammar must fulfill a number of criteria for this to work 
	[see paper]

 - A TreeVisitor API, which provides pre_visit, post_visit and visit_children
	methods for every class in the grammar, including the abstract ones. Each
	class in the AST hierarchy provides a method "visit", which takes a
	TreeVisit object as parameter. 

	Suppose the method "visit" is called on an object X. X::visit will then
	invoke the pre_visit method of the TreeVisitor object for each of its
	(transitive) superclasses (in the class hierarchy, not ancestors in the
	actual syntax tree!), from most general to most specific (i.e., to the node
	itself). 
	
	It then invokes the appropriate children_xxx node of the TreeVisitor object,
	which is responsible for visiting each of the nodes children (the default
	implementation of the children_xxx methods in the TreeVisitor class does
	exactly this; however, this behaviour can be overridden for individual
	TreeVisitor objects). 

	Finally, it calls the post_visit methods of the TreeVisitor object for each
	of its (transitive) superclasses, from most specific to least specific
	(i.e., in the opposite order to the ordering of the pre visit methods).

 - A TreeTransformAPI. The TreeTransform API differs from the TreeVisitor API
	in that it allows to modify the structure of the tree. It does not provide
	methods to modify "abstract" classes. Each class in the AST hierarchy
	provides a method "transform", which takes a TreeTransform object as
	parameter.

	Suppose the method "transform" is called on an object X. X::transform will
	then invoke the corresponding pre_transform method of the TreeTransform
	(pre_X). Note that it does not call any pre_transform methods for X's
	superclasses.

	Then X::transform then calls transform_children on the object returned by
	the pre_x method of the TreeTransform object. If pre_x returned a vector,
	transform_children will be invoked on every element of the vector. Note that
	invoking transform_children on an object can never modify the object itself,
	only its children.

	Finally, X::transform will invoke post_transform on the node returned by the
	pre_x method. Again, if pre_x returned a vector, the post_transform method
	will be invoked on every element of the vector. Intuitively, this means that
	each element of the vector will be replaced by the elements in the vector
	returned by the post_x method. I.e., suppose that pre_x returned 3
	statements for the original statements, and each of the post_x calls
	replaces the respective statement into 3 more statements, the final vector
	will contain 9 statements.

	IMPORTANT NOTE. If a pre_transform method replaces the node by one of its
	children, all the same rules apply - in particular, this means that that
	node will not be pre_transform'ed in turn (although its children will be
	transformed). The user can change this behaviour, if required, by manually
	calling pre_transform on the node before returning it from the pre_transform
	method.
