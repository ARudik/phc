/*
 * This code is autogenerated by MakeTea. Do not edit.
 */

#include "ast.h"
#include "Tree_transform.h"
#include "Tree_visitor.h"

Wildcard* WILDCARD = new Wildcard;

AST_node* AST_node_factory::create(char* name, List<Object*>* args)
{
	List<Object*>::const_iterator i = args->begin();
	
	if(!strcmp(name, "AST_php_script")) {
		AST_php_script* rv = new AST_php_script();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_interface_def_list* arg;
			arg = dynamic_cast<AST_interface_def_list*>(*i);
			assert(arg); // Verify argument type
			rv->interface_defs = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_class_def_list* arg;
			arg = dynamic_cast<AST_class_def_list*>(*i);
			assert(arg); // Verify argument type
			rv->class_defs = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_interface_def")) {
		AST_interface_def* rv = new AST_interface_def();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_interface_name* arg;
			arg = dynamic_cast<Token_interface_name*>(*i);
			assert(arg); // Verify argument type
			rv->interface_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_interface_name_list* arg;
			arg = dynamic_cast<Token_interface_name_list*>(*i);
			assert(arg); // Verify argument type
			rv->extends = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_member_list* arg;
			arg = dynamic_cast<AST_member_list*>(*i);
			assert(arg); // Verify argument type
			rv->members = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_class_def")) {
		AST_class_def* rv = new AST_class_def();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_class_mod* arg;
			arg = dynamic_cast<AST_class_mod*>(*i);
			assert(arg); // Verify argument type
			rv->class_mod = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_class_name* arg;
			arg = dynamic_cast<Token_class_name*>(*i);
			assert(arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_class_name* arg;
			arg = dynamic_cast<Token_class_name*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->extends = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_interface_name_list* arg;
			arg = dynamic_cast<Token_interface_name_list*>(*i);
			assert(arg); // Verify argument type
			rv->implements = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_member_list* arg;
			arg = dynamic_cast<AST_member_list*>(*i);
			assert(arg); // Verify argument type
			rv->members = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_class_mod")) {
		AST_class_mod* rv = new AST_class_mod();
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_abstract = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_final = boolean->value();
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_method")) {
		AST_method* rv = new AST_method();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_signature* arg;
			arg = dynamic_cast<AST_signature*>(*i);
			assert(arg); // Verify argument type
			rv->signature = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_signature")) {
		AST_signature* rv = new AST_signature();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_method_mod* arg;
			arg = dynamic_cast<AST_method_mod*>(*i);
			assert(arg); // Verify argument type
			rv->method_mod = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_method_name* arg;
			arg = dynamic_cast<Token_method_name*>(*i);
			assert(arg); // Verify argument type
			rv->method_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_formal_parameter_list* arg;
			arg = dynamic_cast<AST_formal_parameter_list*>(*i);
			assert(arg); // Verify argument type
			rv->formal_parameters = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_method_mod")) {
		AST_method_mod* rv = new AST_method_mod();
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_public = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_protected = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_private = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_static = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_abstract = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_final = boolean->value();
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_formal_parameter")) {
		AST_formal_parameter* rv = new AST_formal_parameter();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_type* arg;
			arg = dynamic_cast<AST_type*>(*i);
			assert(arg); // Verify argument type
			rv->type = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_variable_name* arg;
			arg = dynamic_cast<Token_variable_name*>(*i);
			assert(arg); // Verify argument type
			rv->variable_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_type")) {
		AST_type* rv = new AST_type();
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_array = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_class_name* arg;
			arg = dynamic_cast<Token_class_name*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_attribute")) {
		AST_attribute* rv = new AST_attribute();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_attr_mod* arg;
			arg = dynamic_cast<AST_attr_mod*>(*i);
			assert(arg); // Verify argument type
			rv->attr_mod = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_variable_name* arg;
			arg = dynamic_cast<Token_variable_name*>(*i);
			assert(arg); // Verify argument type
			rv->variable_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_attr_mod")) {
		AST_attr_mod* rv = new AST_attr_mod();
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_public = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_protected = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_private = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_static = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_const = boolean->value();
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_if")) {
		AST_if* rv = new AST_if();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->iftrue = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->iffalse = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_while")) {
		AST_while* rv = new AST_while();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_do")) {
		AST_do* rv = new AST_do();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_for")) {
		AST_for* rv = new AST_for();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->init = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->cond = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->incr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_foreach")) {
		AST_foreach* rv = new AST_foreach();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->key = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(arg); // Verify argument type
			rv->val = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_switch")) {
		AST_switch* rv = new AST_switch();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_switch_case_list* arg;
			arg = dynamic_cast<AST_switch_case_list*>(*i);
			assert(arg); // Verify argument type
			rv->switch_cases = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_switch_case")) {
		AST_switch_case* rv = new AST_switch_case();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_break")) {
		AST_break* rv = new AST_break();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_continue")) {
		AST_continue* rv = new AST_continue();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_return")) {
		AST_return* rv = new AST_return();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_static_declaration")) {
		AST_static_declaration* rv = new AST_static_declaration();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_variable_name* arg;
			arg = dynamic_cast<Token_variable_name*>(*i);
			assert(arg); // Verify argument type
			rv->variable_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_unset")) {
		AST_unset* rv = new AST_unset();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(arg); // Verify argument type
			rv->variable = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_declare")) {
		AST_declare* rv = new AST_declare();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_directive_list* arg;
			arg = dynamic_cast<AST_directive_list*>(*i);
			assert(arg); // Verify argument type
			rv->directives = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_directive")) {
		AST_directive* rv = new AST_directive();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_directive_name* arg;
			arg = dynamic_cast<Token_directive_name*>(*i);
			assert(arg); // Verify argument type
			rv->directive_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_try")) {
		AST_try* rv = new AST_try();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_catch_list* arg;
			arg = dynamic_cast<AST_catch_list*>(*i);
			assert(arg); // Verify argument type
			rv->catches = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_catch")) {
		AST_catch* rv = new AST_catch();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_class_name* arg;
			arg = dynamic_cast<Token_class_name*>(*i);
			assert(arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_variable_name* arg;
			arg = dynamic_cast<Token_variable_name*>(*i);
			assert(arg); // Verify argument type
			rv->variable_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_statement_list* arg;
			arg = dynamic_cast<AST_statement_list*>(*i);
			assert(arg); // Verify argument type
			rv->statements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_throw")) {
		AST_throw* rv = new AST_throw();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_eval_expr")) {
		AST_eval_expr* rv = new AST_eval_expr();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_nop")) {
		AST_nop* rv = new AST_nop();
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_assignment")) {
		AST_assignment* rv = new AST_assignment();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(arg); // Verify argument type
			rv->variable = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_list_assignment")) {
		AST_list_assignment* rv = new AST_list_assignment();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_list_elements* arg;
			arg = dynamic_cast<AST_list_elements*>(*i);
			assert(arg); // Verify argument type
			rv->list_elements = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_list_elements")) {
		AST_list_elements* rv = new AST_list_elements();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_list_element_list* arg;
			arg = dynamic_cast<AST_list_element_list*>(*i);
			assert(arg); // Verify argument type
			rv->list_elements = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_cast")) {
		AST_cast* rv = new AST_cast();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_cast* arg;
			arg = dynamic_cast<Token_cast*>(*i);
			assert(arg); // Verify argument type
			rv->cast = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_unary_op")) {
		AST_unary_op* rv = new AST_unary_op();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_op* arg;
			arg = dynamic_cast<Token_op*>(*i);
			assert(arg); // Verify argument type
			rv->op = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_bin_op")) {
		AST_bin_op* rv = new AST_bin_op();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->left = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_op* arg;
			arg = dynamic_cast<Token_op*>(*i);
			assert(arg); // Verify argument type
			rv->op = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->right = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_conditional_expr")) {
		AST_conditional_expr* rv = new AST_conditional_expr();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->cond = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->iftrue = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->iffalse = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_ignore_errors")) {
		AST_ignore_errors* rv = new AST_ignore_errors();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_constant")) {
		AST_constant* rv = new AST_constant();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_class_name* arg;
			arg = dynamic_cast<Token_class_name*>(*i);
			assert(arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_constant_name* arg;
			arg = dynamic_cast<Token_constant_name*>(*i);
			assert(arg); // Verify argument type
			rv->constant_name = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_instanceof")) {
		AST_instanceof* rv = new AST_instanceof();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_class_name* arg;
			arg = dynamic_cast<AST_class_name*>(*i);
			assert(arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_variable")) {
		AST_variable* rv = new AST_variable();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_target* arg;
			arg = dynamic_cast<AST_target*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->target = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable_name* arg;
			arg = dynamic_cast<AST_variable_name*>(*i);
			assert(arg); // Verify argument type
			rv->variable_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr_list* arg;
			arg = dynamic_cast<AST_expr_list*>(*i);
			assert(arg); // Verify argument type
			rv->array_indices = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->string_index = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_reflection")) {
		AST_reflection* rv = new AST_reflection();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_pre_op")) {
		AST_pre_op* rv = new AST_pre_op();
		{
			assert(i != args->end()); // Check for too few arguments
			Token_op* arg;
			arg = dynamic_cast<Token_op*>(*i);
			assert(arg); // Verify argument type
			rv->op = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(arg); // Verify argument type
			rv->variable = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_post_op")) {
		AST_post_op* rv = new AST_post_op();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_variable* arg;
			arg = dynamic_cast<AST_variable*>(*i);
			assert(arg); // Verify argument type
			rv->variable = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Token_op* arg;
			arg = dynamic_cast<Token_op*>(*i);
			assert(arg); // Verify argument type
			rv->op = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_array")) {
		AST_array* rv = new AST_array();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_array_elem_list* arg;
			arg = dynamic_cast<AST_array_elem_list*>(*i);
			assert(arg); // Verify argument type
			rv->array_elems = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_array_elem")) {
		AST_array_elem* rv = new AST_array_elem();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->key = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->val = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_method_invocation")) {
		AST_method_invocation* rv = new AST_method_invocation();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_target* arg;
			arg = dynamic_cast<AST_target*>(*i);
			assert(arg); // Verify argument type
			rv->target = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_method_name* arg;
			arg = dynamic_cast<AST_method_name*>(*i);
			assert(arg); // Verify argument type
			rv->method_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_actual_parameter_list* arg;
			arg = dynamic_cast<AST_actual_parameter_list*>(*i);
			assert(arg); // Verify argument type
			rv->actual_parameters = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_actual_parameter")) {
		AST_actual_parameter* rv = new AST_actual_parameter();
		{
			assert(i != args->end()); // Check for too few arguments
			Boolean* boolean = dynamic_cast<Boolean*>(*i++);
			assert(boolean); // Verify argument type
			rv->is_ref = boolean->value();
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_new")) {
		AST_new* rv = new AST_new();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_class_name* arg;
			arg = dynamic_cast<AST_class_name*>(*i);
			assert(arg); // Verify argument type
			rv->class_name = arg;
			i++;
		}
		{
			assert(i != args->end()); // Check for too few arguments
			AST_actual_parameter_list* arg;
			arg = dynamic_cast<AST_actual_parameter_list*>(*i);
			assert(arg); // Verify argument type
			rv->actual_parameters = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_clone")) {
		AST_clone* rv = new AST_clone();
		{
			assert(i != args->end()); // Check for too few arguments
			AST_expr* arg;
			arg = dynamic_cast<AST_expr*>(*i);
			assert(arg); // Verify argument type
			rv->expr = arg;
			i++;
		}
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_interface_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_interface_name* rv = new Token_interface_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_class_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_class_name* rv = new Token_class_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_method_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_method_name* rv = new Token_method_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_variable_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_variable_name* rv = new Token_variable_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_directive_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_directive_name* rv = new Token_directive_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_cast")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_cast* rv = new Token_cast(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_op")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_op* rv = new Token_op(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "Token_constant_name")) {
		assert(i != args->end()); // Check for too few arguments
		String* string = dynamic_cast<String*>(*i++);
		assert(string); // Verify argument type
		Token_constant_name* rv = new Token_constant_name(string);
		assert(i == args->end()); // Check for too many arguments
		return rv;
	}
	if(!strcmp(name, "AST_interface_def_list")) {
		AST_interface_def_list* rv = new AST_interface_def_list;
		for(; i != args->end(); i++)
		{
			AST_interface_def* arg = dynamic_cast<AST_interface_def*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_class_def_list")) {
		AST_class_def_list* rv = new AST_class_def_list;
		for(; i != args->end(); i++)
		{
			AST_class_def* arg = dynamic_cast<AST_class_def*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "Token_interface_name_list")) {
		Token_interface_name_list* rv = new Token_interface_name_list;
		for(; i != args->end(); i++)
		{
			Token_interface_name* arg = dynamic_cast<Token_interface_name*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_member_list")) {
		AST_member_list* rv = new AST_member_list;
		for(; i != args->end(); i++)
		{
			AST_member* arg = dynamic_cast<AST_member*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_statement_list")) {
		AST_statement_list* rv = new AST_statement_list;
		for(; i != args->end(); i++)
		{
			AST_statement* arg = dynamic_cast<AST_statement*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_formal_parameter_list")) {
		AST_formal_parameter_list* rv = new AST_formal_parameter_list;
		for(; i != args->end(); i++)
		{
			AST_formal_parameter* arg = dynamic_cast<AST_formal_parameter*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_switch_case_list")) {
		AST_switch_case_list* rv = new AST_switch_case_list;
		for(; i != args->end(); i++)
		{
			AST_switch_case* arg = dynamic_cast<AST_switch_case*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_directive_list")) {
		AST_directive_list* rv = new AST_directive_list;
		for(; i != args->end(); i++)
		{
			AST_directive* arg = dynamic_cast<AST_directive*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_catch_list")) {
		AST_catch_list* rv = new AST_catch_list;
		for(; i != args->end(); i++)
		{
			AST_catch* arg = dynamic_cast<AST_catch*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_list_element_list")) {
		AST_list_element_list* rv = new AST_list_element_list;
		for(; i != args->end(); i++)
		{
			AST_list_element* arg = dynamic_cast<AST_list_element*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_expr_list")) {
		AST_expr_list* rv = new AST_expr_list;
		for(; i != args->end(); i++)
		{
			AST_expr* arg = dynamic_cast<AST_expr*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_array_elem_list")) {
		AST_array_elem_list* rv = new AST_array_elem_list;
		for(; i != args->end(); i++)
		{
			AST_array_elem* arg = dynamic_cast<AST_array_elem*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	if(!strcmp(name, "AST_actual_parameter_list")) {
		AST_actual_parameter_list* rv = new AST_actual_parameter_list;
		for(; i != args->end(); i++)
		{
			AST_actual_parameter* arg = dynamic_cast<AST_actual_parameter*>(*i);
			assert(!*i || arg); // Verify argument type
			rv->push_back(arg);
		}
		return rv;
	}
	
	cout << "AST_node_factory::create: unknown class '" << name << "'" << endl;
	abort();
}

AST_node* AST_node_factory::create(char* name, Object* arg)
{
	List<Object*>* list = new List<Object*>;
	list->push_back(arg);
	return create(name, list);
}

AST_node::AST_node()
{
	// Constructor gets called because all classes inherit from
	// AST_node virtually; also, because maketea knows AST_node is
	// abstract, it won't add a constructor itself
	attrs = new AttrMap();
}

bool AST_node::deep_equals(Object* other)
{
	AST_node* that = dynamic_cast<AST_node*>(other);
	if(!that) return false;
	
	if(!Object::deep_equals(that)) return false;
	
	if(attrs == NULL)
		{ if(that->attrs != NULL) return false; }
	else
		{ if(!attrs->deep_equals(that->attrs)) return false; }
	
	return true;
}

AST_node* AST_node::deep_clone(Object* partial_result)
{
	// abstract class
	AST_node* clone = dynamic_cast<AST_node*>(partial_result);
	assert(clone);
	
	Object::deep_clone(clone);
	
	if(attrs)
		clone->attrs = attrs->deep_clone();
	else
		clone->attrs = NULL;
	assert(!attrs || clone->attrs);
	
	return clone;
}

bool AST_node::try_match(Object* pattern)
{
	AST_node* that = dynamic_cast<AST_node*>(pattern);
	if(!that) return false;
	
	
	
	return true;
}

void AST_node::replace_wildcards(Object* pattern)
{
	AST_node* that = dynamic_cast<AST_node*>(pattern);
	assert(that);
	
	
}









int AST_node::get_line_number()
{
	Integer* i = dynamic_cast<Integer*>(attrs->get("phc.line_number"));
	if(i != NULL)
	return i->value();
	else
	return 0;
}

String* AST_node::get_filename()
{
	return dynamic_cast<String*>(attrs->get("phc.filename"));
}

bool Token_interface_name_list::deep_equals(Object* other)
{
	Token_interface_name_list* that = dynamic_cast<Token_interface_name_list*>(other);
	if(!that) return false;
	
	if(!List<Token_interface_name*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

Token_interface_name_list* Token_interface_name_list::deep_clone(Object* partial_result)
{
	Token_interface_name_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_interface_name_list*>(partial_result);
	else
		clone = new Token_interface_name_list();
	assert(clone);
	
	List<Token_interface_name*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool Token_interface_name_list::try_match(Object* pattern)
{
	Token_interface_name_list* that = dynamic_cast<Token_interface_name_list*>(pattern);
	if(!that) return false;
	
	if(!List<Token_interface_name*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void Token_interface_name_list::replace_wildcards(Object* pattern)
{
	Token_interface_name_list* that = dynamic_cast<Token_interface_name_list*>(pattern);
	assert(that);
	
	List<Token_interface_name*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void Token_interface_name_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_interface_name_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_interface_name_list(this);
}

void Token_interface_name_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_interface_name_list(this);
}

void Token_interface_name_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_interface_name_list(this);
	visitor->post_node(this);
}

Token_interface_name_list* Token_interface_name_list::transform(Tree_transform* transform)
{
	Token_interface_name_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_interface_name_list* Token_interface_name_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_interface_name_list(this);
}

void Token_interface_name_list::transform_children(Tree_transform* transform)
{
	transform->children_interface_name_list(this);
}

Token_interface_name_list* Token_interface_name_list::post_transform(Tree_transform* transform)
{
	return transform->post_interface_name_list(this);
}

bool AST_formal_parameter_list::deep_equals(Object* other)
{
	AST_formal_parameter_list* that = dynamic_cast<AST_formal_parameter_list*>(other);
	if(!that) return false;
	
	if(!List<AST_formal_parameter*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_formal_parameter_list* AST_formal_parameter_list::deep_clone(Object* partial_result)
{
	AST_formal_parameter_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_formal_parameter_list*>(partial_result);
	else
		clone = new AST_formal_parameter_list();
	assert(clone);
	
	List<AST_formal_parameter*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_formal_parameter_list::try_match(Object* pattern)
{
	AST_formal_parameter_list* that = dynamic_cast<AST_formal_parameter_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_formal_parameter*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_formal_parameter_list::replace_wildcards(Object* pattern)
{
	AST_formal_parameter_list* that = dynamic_cast<AST_formal_parameter_list*>(pattern);
	assert(that);
	
	List<AST_formal_parameter*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_formal_parameter_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_formal_parameter_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_formal_parameter_list(this);
}

void AST_formal_parameter_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_formal_parameter_list(this);
}

void AST_formal_parameter_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_formal_parameter_list(this);
	visitor->post_node(this);
}

AST_formal_parameter_list* AST_formal_parameter_list::transform(Tree_transform* transform)
{
	AST_formal_parameter_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_formal_parameter_list* AST_formal_parameter_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_formal_parameter_list(this);
}

void AST_formal_parameter_list::transform_children(Tree_transform* transform)
{
	transform->children_formal_parameter_list(this);
}

AST_formal_parameter_list* AST_formal_parameter_list::post_transform(Tree_transform* transform)
{
	return transform->post_formal_parameter_list(this);
}

bool AST_directive_list::deep_equals(Object* other)
{
	AST_directive_list* that = dynamic_cast<AST_directive_list*>(other);
	if(!that) return false;
	
	if(!List<AST_directive*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_directive_list* AST_directive_list::deep_clone(Object* partial_result)
{
	AST_directive_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_directive_list*>(partial_result);
	else
		clone = new AST_directive_list();
	assert(clone);
	
	List<AST_directive*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_directive_list::try_match(Object* pattern)
{
	AST_directive_list* that = dynamic_cast<AST_directive_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_directive*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_directive_list::replace_wildcards(Object* pattern)
{
	AST_directive_list* that = dynamic_cast<AST_directive_list*>(pattern);
	assert(that);
	
	List<AST_directive*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_directive_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_directive_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_directive_list(this);
}

void AST_directive_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_directive_list(this);
}

void AST_directive_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_directive_list(this);
	visitor->post_node(this);
}

AST_directive_list* AST_directive_list::transform(Tree_transform* transform)
{
	AST_directive_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_directive_list* AST_directive_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_directive_list(this);
}

void AST_directive_list::transform_children(Tree_transform* transform)
{
	transform->children_directive_list(this);
}

AST_directive_list* AST_directive_list::post_transform(Tree_transform* transform)
{
	return transform->post_directive_list(this);
}

bool AST_list_element_list::deep_equals(Object* other)
{
	AST_list_element_list* that = dynamic_cast<AST_list_element_list*>(other);
	if(!that) return false;
	
	if(!List<AST_list_element*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_list_element_list* AST_list_element_list::deep_clone(Object* partial_result)
{
	AST_list_element_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_list_element_list*>(partial_result);
	else
		clone = new AST_list_element_list();
	assert(clone);
	
	List<AST_list_element*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_list_element_list::try_match(Object* pattern)
{
	AST_list_element_list* that = dynamic_cast<AST_list_element_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_list_element*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_list_element_list::replace_wildcards(Object* pattern)
{
	AST_list_element_list* that = dynamic_cast<AST_list_element_list*>(pattern);
	assert(that);
	
	List<AST_list_element*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_list_element_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_list_element_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_list_element_list(this);
}

void AST_list_element_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_list_element_list(this);
}

void AST_list_element_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_list_element_list(this);
	visitor->post_node(this);
}

AST_list_element_list* AST_list_element_list::transform(Tree_transform* transform)
{
	AST_list_element_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_list_element_list* AST_list_element_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_list_element_list(this);
}

void AST_list_element_list::transform_children(Tree_transform* transform)
{
	transform->children_list_element_list(this);
}

AST_list_element_list* AST_list_element_list::post_transform(Tree_transform* transform)
{
	return transform->post_list_element_list(this);
}

bool AST_expr_list::deep_equals(Object* other)
{
	AST_expr_list* that = dynamic_cast<AST_expr_list*>(other);
	if(!that) return false;
	
	if(!List<AST_expr*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_expr_list* AST_expr_list::deep_clone(Object* partial_result)
{
	AST_expr_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_expr_list*>(partial_result);
	else
		clone = new AST_expr_list();
	assert(clone);
	
	List<AST_expr*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_expr_list::try_match(Object* pattern)
{
	AST_expr_list* that = dynamic_cast<AST_expr_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_expr*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_expr_list::replace_wildcards(Object* pattern)
{
	AST_expr_list* that = dynamic_cast<AST_expr_list*>(pattern);
	assert(that);
	
	List<AST_expr*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_expr_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_expr_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_expr_list(this);
}

void AST_expr_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_expr_list(this);
}

void AST_expr_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_expr_list(this);
	visitor->post_node(this);
}

AST_expr_list* AST_expr_list::transform(Tree_transform* transform)
{
	AST_expr_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr_list* AST_expr_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_expr_list(this);
}

void AST_expr_list::transform_children(Tree_transform* transform)
{
	transform->children_expr_list(this);
}

AST_expr_list* AST_expr_list::post_transform(Tree_transform* transform)
{
	return transform->post_expr_list(this);
}

bool AST_array_elem_list::deep_equals(Object* other)
{
	AST_array_elem_list* that = dynamic_cast<AST_array_elem_list*>(other);
	if(!that) return false;
	
	if(!List<AST_array_elem*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_array_elem_list* AST_array_elem_list::deep_clone(Object* partial_result)
{
	AST_array_elem_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_array_elem_list*>(partial_result);
	else
		clone = new AST_array_elem_list();
	assert(clone);
	
	List<AST_array_elem*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_array_elem_list::try_match(Object* pattern)
{
	AST_array_elem_list* that = dynamic_cast<AST_array_elem_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_array_elem*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_array_elem_list::replace_wildcards(Object* pattern)
{
	AST_array_elem_list* that = dynamic_cast<AST_array_elem_list*>(pattern);
	assert(that);
	
	List<AST_array_elem*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_array_elem_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_array_elem_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_array_elem_list(this);
}

void AST_array_elem_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_array_elem_list(this);
}

void AST_array_elem_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_array_elem_list(this);
	visitor->post_node(this);
}

AST_array_elem_list* AST_array_elem_list::transform(Tree_transform* transform)
{
	AST_array_elem_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_array_elem_list* AST_array_elem_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_array_elem_list(this);
}

void AST_array_elem_list::transform_children(Tree_transform* transform)
{
	transform->children_array_elem_list(this);
}

AST_array_elem_list* AST_array_elem_list::post_transform(Tree_transform* transform)
{
	return transform->post_array_elem_list(this);
}

bool AST_actual_parameter_list::deep_equals(Object* other)
{
	AST_actual_parameter_list* that = dynamic_cast<AST_actual_parameter_list*>(other);
	if(!that) return false;
	
	if(!List<AST_actual_parameter*>::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_actual_parameter_list* AST_actual_parameter_list::deep_clone(Object* partial_result)
{
	AST_actual_parameter_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_actual_parameter_list*>(partial_result);
	else
		clone = new AST_actual_parameter_list();
	assert(clone);
	
	List<AST_actual_parameter*>::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_actual_parameter_list::try_match(Object* pattern)
{
	AST_actual_parameter_list* that = dynamic_cast<AST_actual_parameter_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_actual_parameter*>::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_actual_parameter_list::replace_wildcards(Object* pattern)
{
	AST_actual_parameter_list* that = dynamic_cast<AST_actual_parameter_list*>(pattern);
	assert(that);
	
	List<AST_actual_parameter*>::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}

void AST_actual_parameter_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_actual_parameter_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_actual_parameter_list(this);
}

void AST_actual_parameter_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_actual_parameter_list(this);
}

void AST_actual_parameter_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_actual_parameter_list(this);
	visitor->post_node(this);
}

AST_actual_parameter_list* AST_actual_parameter_list::transform(Tree_transform* transform)
{
	AST_actual_parameter_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_actual_parameter_list* AST_actual_parameter_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_actual_parameter_list(this);
}

void AST_actual_parameter_list::transform_children(Tree_transform* transform)
{
	transform->children_actual_parameter_list(this);
}

AST_actual_parameter_list* AST_actual_parameter_list::post_transform(Tree_transform* transform)
{
	return transform->post_actual_parameter_list(this);
}

AST_php_script::AST_php_script()
{
	init();
}

AST_php_script::AST_php_script(AST_interface_def_list* interface_defs, AST_class_def_list* class_defs)
{
	init();
	this->interface_defs = interface_defs;
	this->class_defs = class_defs;
}

bool AST_php_script::deep_equals(Object* other)
{
	AST_php_script* that = dynamic_cast<AST_php_script*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(interface_defs == NULL)
		{ if(that->interface_defs != NULL) return false; }
	else
		{ if(!interface_defs->deep_equals(that->interface_defs)) return false; }
	if(class_defs == NULL)
		{ if(that->class_defs != NULL) return false; }
	else
		{ if(!class_defs->deep_equals(that->class_defs)) return false; }
	
	return true;
}

AST_php_script* AST_php_script::deep_clone(Object* partial_result)
{
	AST_php_script* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_php_script*>(partial_result);
	else
		clone = new AST_php_script();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	if(interface_defs)
		clone->interface_defs = interface_defs->deep_clone();
	else
		clone->interface_defs = NULL;
	assert(!interface_defs || clone->interface_defs);
	
	if(class_defs)
		clone->class_defs = class_defs->deep_clone();
	else
		clone->class_defs = NULL;
	assert(!class_defs || clone->class_defs);
	
	return clone;
}

bool AST_php_script::try_match(Object* pattern)
{
	AST_php_script* that = dynamic_cast<AST_php_script*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->interface_defs) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(interface_defs == NULL)
		{ if(that->interface_defs != NULL) return false; }
	else
		{ if(!interface_defs->try_match(that->interface_defs)) return false; }
	if(dynamic_cast<void*>(that->class_defs) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_defs == NULL)
		{ if(that->class_defs != NULL) return false; }
	else
		{ if(!class_defs->try_match(that->class_defs)) return false; }
	
	return true;
}

void AST_php_script::replace_wildcards(Object* pattern)
{
	AST_php_script* that = dynamic_cast<AST_php_script*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->interface_defs) == dynamic_cast<void*>(WILDCARD))
		{ that->interface_defs = interface_defs; }
	else if(interface_defs != NULL)
		{ interface_defs->replace_wildcards(that->interface_defs); }
	if(dynamic_cast<void*>(that->class_defs) == dynamic_cast<void*>(WILDCARD))
		{ that->class_defs = class_defs; }
	else if(class_defs != NULL)
		{ class_defs->replace_wildcards(that->class_defs); }
}

AST_php_script* AST_php_script::transform(Tree_transform* transform)
{
	AST_php_script* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_php_script* AST_php_script::pre_transform(Tree_transform* transform)
{
	return transform->pre_php_script(this);
}

void AST_php_script::transform_children(Tree_transform* transform)
{
	transform->children_php_script(this);
}

AST_php_script* AST_php_script::post_transform(Tree_transform* transform)
{
	return transform->post_php_script(this);
}

void AST_php_script::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_php_script::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_php_script(this);
}

void AST_php_script::visit_children(Tree_visitor* visitor)
{
	visitor->children_php_script(this);
}

void AST_php_script::post_visit(Tree_visitor* visitor)
{
	visitor->post_php_script(this);
	visitor->post_node(this);
}

void AST_php_script::init()
{
	interface_defs = new AST_interface_def_list;
	class_defs = new AST_class_def_list;
	class_defs->push_back(new AST_class_def("%MAIN%"));
}

AST_class_def* AST_php_script::get_class_def(const char* name)
{
	AST_class_def_list::const_iterator i;
	for(i = class_defs->begin(); i != class_defs->end(); i++)
	{
	AST_class_def* class_def = dynamic_cast<AST_class_def*>(*i);
	if(class_def && *class_def->class_name->value == name)
	return class_def;
	}
	
	return NULL;
}

AST_class_mod::AST_class_mod()
{
}

AST_class_mod::AST_class_mod(bool is_abstract, bool is_final)
{
	this->is_abstract = is_abstract;
	this->is_final = is_final;
}

bool AST_class_mod::deep_equals(Object* other)
{
	AST_class_mod* that = dynamic_cast<AST_class_mod*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(is_abstract != that->is_abstract) return false;
	if(is_final != that->is_final) return false;
	
	return true;
}

AST_class_mod* AST_class_mod::deep_clone(Object* partial_result)
{
	AST_class_mod* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_class_mod*>(partial_result);
	else
		clone = new AST_class_mod();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	clone->is_abstract = is_abstract;
	
	clone->is_final = is_final;
	
	return clone;
}

bool AST_class_mod::try_match(Object* pattern)
{
	AST_class_mod* that = dynamic_cast<AST_class_mod*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(is_abstract != that->is_abstract) return false;
	if(is_final != that->is_final) return false;
	
	return true;
}

void AST_class_mod::replace_wildcards(Object* pattern)
{
	AST_class_mod* that = dynamic_cast<AST_class_mod*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}

AST_class_mod* AST_class_mod::transform(Tree_transform* transform)
{
	AST_class_mod* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_class_mod* AST_class_mod::pre_transform(Tree_transform* transform)
{
	return transform->pre_class_mod(this);
}

void AST_class_mod::transform_children(Tree_transform* transform)
{
	transform->children_class_mod(this);
}

AST_class_mod* AST_class_mod::post_transform(Tree_transform* transform)
{
	return transform->post_class_mod(this);
}

void AST_class_mod::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_class_mod::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_class_mod(this);
}

void AST_class_mod::visit_children(Tree_visitor* visitor)
{
	visitor->children_class_mod(this);
}

void AST_class_mod::post_visit(Tree_visitor* visitor)
{
	visitor->post_class_mod(this);
	visitor->post_node(this);
}

AST_signature::AST_signature()
{
}

AST_signature::AST_signature(AST_method_mod* method_mod, bool is_ref, Token_method_name* method_name, AST_formal_parameter_list* formal_parameters)
{
	this->method_mod = method_mod;
	this->is_ref = is_ref;
	this->method_name = method_name;
	this->formal_parameters = formal_parameters;
}

AST_signature::AST_signature(const char* name)
{
	this->method_mod = AST_method_mod::new_PUBLIC();
	this->is_ref = false;
	this->method_name = new Token_method_name(new String(name));
	this->formal_parameters = new AST_formal_parameter_list;
}

bool AST_signature::deep_equals(Object* other)
{
	AST_signature* that = dynamic_cast<AST_signature*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(method_mod == NULL)
		{ if(that->method_mod != NULL) return false; }
	else
		{ if(!method_mod->deep_equals(that->method_mod)) return false; }
	if(is_ref != that->is_ref) return false;
	if(method_name == NULL)
		{ if(that->method_name != NULL) return false; }
	else
		{ if(!method_name->deep_equals(that->method_name)) return false; }
	if(formal_parameters == NULL)
		{ if(that->formal_parameters != NULL) return false; }
	else
		{ if(!formal_parameters->deep_equals(that->formal_parameters)) return false; }
	
	return true;
}

AST_signature* AST_signature::deep_clone(Object* partial_result)
{
	AST_signature* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_signature*>(partial_result);
	else
		clone = new AST_signature();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	if(method_mod)
		clone->method_mod = method_mod->deep_clone();
	else
		clone->method_mod = NULL;
	assert(!method_mod || clone->method_mod);
	
	clone->is_ref = is_ref;
	
	if(method_name)
		clone->method_name = method_name->deep_clone();
	else
		clone->method_name = NULL;
	assert(!method_name || clone->method_name);
	
	if(formal_parameters)
		clone->formal_parameters = formal_parameters->deep_clone();
	else
		clone->formal_parameters = NULL;
	assert(!formal_parameters || clone->formal_parameters);
	
	return clone;
}

bool AST_signature::try_match(Object* pattern)
{
	AST_signature* that = dynamic_cast<AST_signature*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->method_mod) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(method_mod == NULL)
		{ if(that->method_mod != NULL) return false; }
	else
		{ if(!method_mod->try_match(that->method_mod)) return false; }
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->method_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(method_name == NULL)
		{ if(that->method_name != NULL) return false; }
	else
		{ if(!method_name->try_match(that->method_name)) return false; }
	if(dynamic_cast<void*>(that->formal_parameters) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(formal_parameters == NULL)
		{ if(that->formal_parameters != NULL) return false; }
	else
		{ if(!formal_parameters->try_match(that->formal_parameters)) return false; }
	
	return true;
}

void AST_signature::replace_wildcards(Object* pattern)
{
	AST_signature* that = dynamic_cast<AST_signature*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->method_mod) == dynamic_cast<void*>(WILDCARD))
		{ that->method_mod = method_mod; }
	else if(method_mod != NULL)
		{ method_mod->replace_wildcards(that->method_mod); }
	if(dynamic_cast<void*>(that->method_name) == dynamic_cast<void*>(WILDCARD))
		{ that->method_name = method_name; }
	else if(method_name != NULL)
		{ method_name->replace_wildcards(that->method_name); }
	if(dynamic_cast<void*>(that->formal_parameters) == dynamic_cast<void*>(WILDCARD))
		{ that->formal_parameters = formal_parameters; }
	else if(formal_parameters != NULL)
		{ formal_parameters->replace_wildcards(that->formal_parameters); }
}

AST_signature* AST_signature::transform(Tree_transform* transform)
{
	AST_signature* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_signature* AST_signature::pre_transform(Tree_transform* transform)
{
	return transform->pre_signature(this);
}

void AST_signature::transform_children(Tree_transform* transform)
{
	transform->children_signature(this);
}

AST_signature* AST_signature::post_transform(Tree_transform* transform)
{
	return transform->post_signature(this);
}

void AST_signature::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_signature::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_signature(this);
}

void AST_signature::visit_children(Tree_visitor* visitor)
{
	visitor->children_signature(this);
}

void AST_signature::post_visit(Tree_visitor* visitor)
{
	visitor->post_signature(this);
	visitor->post_node(this);
}

AST_method_mod::AST_method_mod()
{
}

AST_method_mod::AST_method_mod(bool is_public, bool is_protected, bool is_private, bool is_static, bool is_abstract, bool is_final)
{
	this->is_public = is_public;
	this->is_protected = is_protected;
	this->is_private = is_private;
	this->is_static = is_static;
	this->is_abstract = is_abstract;
	this->is_final = is_final;
}

AST_method_mod::AST_method_mod(AST_method_mod* a, AST_method_mod* b)
{
	this->is_public 		= a->is_public		|| b->is_public;
	this->is_protected	= a->is_protected	|| b->is_protected;
	this->is_private		= a->is_private	|| b->is_private;
	this->is_static		= a->is_static		|| b->is_static;
	this->is_abstract		= a->is_abstract	|| b->is_abstract;
	this->is_final			= a->is_final		|| b->is_final;
}

bool AST_method_mod::deep_equals(Object* other)
{
	AST_method_mod* that = dynamic_cast<AST_method_mod*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(is_public != that->is_public) return false;
	if(is_protected != that->is_protected) return false;
	if(is_private != that->is_private) return false;
	if(is_static != that->is_static) return false;
	if(is_abstract != that->is_abstract) return false;
	if(is_final != that->is_final) return false;
	
	return true;
}

AST_method_mod* AST_method_mod::deep_clone(Object* partial_result)
{
	AST_method_mod* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_method_mod*>(partial_result);
	else
		clone = new AST_method_mod();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	clone->is_public = is_public;
	
	clone->is_protected = is_protected;
	
	clone->is_private = is_private;
	
	clone->is_static = is_static;
	
	clone->is_abstract = is_abstract;
	
	clone->is_final = is_final;
	
	return clone;
}

bool AST_method_mod::try_match(Object* pattern)
{
	AST_method_mod* that = dynamic_cast<AST_method_mod*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(is_public != that->is_public) return false;
	if(is_protected != that->is_protected) return false;
	if(is_private != that->is_private) return false;
	if(is_static != that->is_static) return false;
	if(is_abstract != that->is_abstract) return false;
	if(is_final != that->is_final) return false;
	
	return true;
}

void AST_method_mod::replace_wildcards(Object* pattern)
{
	AST_method_mod* that = dynamic_cast<AST_method_mod*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}

AST_method_mod* AST_method_mod::transform(Tree_transform* transform)
{
	AST_method_mod* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_method_mod* AST_method_mod::pre_transform(Tree_transform* transform)
{
	return transform->pre_method_mod(this);
}

void AST_method_mod::transform_children(Tree_transform* transform)
{
	transform->children_method_mod(this);
}

AST_method_mod* AST_method_mod::post_transform(Tree_transform* transform)
{
	return transform->post_method_mod(this);
}

void AST_method_mod::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_method_mod::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_method_mod(this);
}

void AST_method_mod::visit_children(Tree_visitor* visitor)
{
	visitor->children_method_mod(this);
}

void AST_method_mod::post_visit(Tree_visitor* visitor)
{
	visitor->post_method_mod(this);
	visitor->post_node(this);
}

AST_method_mod* AST_method_mod::new_PUBLIC()
{
	return new AST_method_mod(true, false, false, false, false, false);
}

AST_method_mod* AST_method_mod::new_PROTECTED()
{
	return new AST_method_mod(false, true, false, false, false, false);
}

AST_method_mod* AST_method_mod::new_PRIVATE()
{
	return new AST_method_mod(false, false, true, false, false, false);
}

AST_method_mod* AST_method_mod::new_STATIC()
{
	return new AST_method_mod(false, false, false, true, false, false);
}

AST_method_mod* AST_method_mod::new_ABSTRACT()
{
	return new AST_method_mod(false, false, false, false, true, false);
}

AST_method_mod* AST_method_mod::new_FINAL()
{
	return new AST_method_mod(false, false, false, false, false, true);
}

AST_formal_parameter::AST_formal_parameter()
{
}

AST_formal_parameter::AST_formal_parameter(AST_type* type, bool is_ref, Token_variable_name* variable_name, AST_expr* expr)
{
	this->type = type;
	this->is_ref = is_ref;
	this->variable_name = variable_name;
	this->expr = expr;
}

AST_formal_parameter::AST_formal_parameter(AST_type* type, Token_variable_name* name)
{
	this->type = type;
	this->is_ref = false;
	this->variable_name = name;
	this->expr = NULL;
}

AST_formal_parameter::AST_formal_parameter(AST_type* type, bool is_ref, Token_variable_name* name)
{
	this->type = type;
	this->is_ref = is_ref;
	this->variable_name = name;
	this->expr = NULL;
}

bool AST_formal_parameter::deep_equals(Object* other)
{
	AST_formal_parameter* that = dynamic_cast<AST_formal_parameter*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(type == NULL)
		{ if(that->type != NULL) return false; }
	else
		{ if(!type->deep_equals(that->type)) return false; }
	if(is_ref != that->is_ref) return false;
	if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->deep_equals(that->variable_name)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_formal_parameter* AST_formal_parameter::deep_clone(Object* partial_result)
{
	AST_formal_parameter* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_formal_parameter*>(partial_result);
	else
		clone = new AST_formal_parameter();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	if(type)
		clone->type = type->deep_clone();
	else
		clone->type = NULL;
	assert(!type || clone->type);
	
	clone->is_ref = is_ref;
	
	if(variable_name)
		clone->variable_name = variable_name->deep_clone();
	else
		clone->variable_name = NULL;
	assert(!variable_name || clone->variable_name);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_formal_parameter::try_match(Object* pattern)
{
	AST_formal_parameter* that = dynamic_cast<AST_formal_parameter*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->type) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(type == NULL)
		{ if(that->type != NULL) return false; }
	else
		{ if(!type->try_match(that->type)) return false; }
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->try_match(that->variable_name)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_formal_parameter::replace_wildcards(Object* pattern)
{
	AST_formal_parameter* that = dynamic_cast<AST_formal_parameter*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->type) == dynamic_cast<void*>(WILDCARD))
		{ that->type = type; }
	else if(type != NULL)
		{ type->replace_wildcards(that->type); }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ that->variable_name = variable_name; }
	else if(variable_name != NULL)
		{ variable_name->replace_wildcards(that->variable_name); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_formal_parameter_list* AST_formal_parameter::transform(Tree_transform* transform)
{
	AST_formal_parameter_list* node = pre_transform(transform);
	AST_formal_parameter_list::const_iterator i;
	AST_formal_parameter_list* new_v = new AST_formal_parameter_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_formal_parameter_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_formal_parameter_list* AST_formal_parameter::pre_transform(Tree_transform* transform)
{
	AST_formal_parameter_list* new_v = new AST_formal_parameter_list;
	transform->pre_formal_parameter(this, new_v);
	return new_v;
}

void AST_formal_parameter::transform_children(Tree_transform* transform)
{
	transform->children_formal_parameter(this);
}

AST_formal_parameter_list* AST_formal_parameter::post_transform(Tree_transform* transform)
{
	AST_formal_parameter_list* new_v = new AST_formal_parameter_list;
	transform->post_formal_parameter(this, new_v);
	return new_v;
}

void AST_formal_parameter::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_formal_parameter::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_formal_parameter(this);
}

void AST_formal_parameter::visit_children(Tree_visitor* visitor)
{
	visitor->children_formal_parameter(this);
}

void AST_formal_parameter::post_visit(Tree_visitor* visitor)
{
	visitor->post_formal_parameter(this);
	visitor->post_node(this);
}

AST_type::AST_type()
{
}

AST_type::AST_type(bool is_array, Token_class_name* class_name)
{
	this->is_array = is_array;
	this->class_name = class_name;
}

bool AST_type::deep_equals(Object* other)
{
	AST_type* that = dynamic_cast<AST_type*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(is_array != that->is_array) return false;
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	
	return true;
}

AST_type* AST_type::deep_clone(Object* partial_result)
{
	AST_type* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_type*>(partial_result);
	else
		clone = new AST_type();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	clone->is_array = is_array;
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	return clone;
}

bool AST_type::try_match(Object* pattern)
{
	AST_type* that = dynamic_cast<AST_type*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(is_array != that->is_array) return false;
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	
	return true;
}

void AST_type::replace_wildcards(Object* pattern)
{
	AST_type* that = dynamic_cast<AST_type*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
}

AST_type* AST_type::transform(Tree_transform* transform)
{
	AST_type* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_type* AST_type::pre_transform(Tree_transform* transform)
{
	return transform->pre_type(this);
}

void AST_type::transform_children(Tree_transform* transform)
{
	transform->children_type(this);
}

AST_type* AST_type::post_transform(Tree_transform* transform)
{
	return transform->post_type(this);
}

void AST_type::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_type::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_type(this);
}

void AST_type::visit_children(Tree_visitor* visitor)
{
	visitor->children_type(this);
}

void AST_type::post_visit(Tree_visitor* visitor)
{
	visitor->post_type(this);
	visitor->post_node(this);
}

AST_attr_mod::AST_attr_mod()
{
}

AST_attr_mod::AST_attr_mod(bool is_public, bool is_protected, bool is_private, bool is_static, bool is_const)
{
	this->is_public = is_public;
	this->is_protected = is_protected;
	this->is_private = is_private;
	this->is_static = is_static;
	this->is_const = is_const;
}

AST_attr_mod::AST_attr_mod(AST_method_mod* mm)
{
	if(mm->is_final)
	phc_error(ERR_FINAL_VARS, mm->get_filename(), mm->get_line_number());
	
	this->is_public = mm->is_public;
	this->is_protected = mm->is_protected;
	this->is_private = mm->is_private;
	this->is_static = mm->is_static;
	this->is_const = false;
}

bool AST_attr_mod::deep_equals(Object* other)
{
	AST_attr_mod* that = dynamic_cast<AST_attr_mod*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(is_public != that->is_public) return false;
	if(is_protected != that->is_protected) return false;
	if(is_private != that->is_private) return false;
	if(is_static != that->is_static) return false;
	if(is_const != that->is_const) return false;
	
	return true;
}

AST_attr_mod* AST_attr_mod::deep_clone(Object* partial_result)
{
	AST_attr_mod* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_attr_mod*>(partial_result);
	else
		clone = new AST_attr_mod();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	clone->is_public = is_public;
	
	clone->is_protected = is_protected;
	
	clone->is_private = is_private;
	
	clone->is_static = is_static;
	
	clone->is_const = is_const;
	
	return clone;
}

bool AST_attr_mod::try_match(Object* pattern)
{
	AST_attr_mod* that = dynamic_cast<AST_attr_mod*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(is_public != that->is_public) return false;
	if(is_protected != that->is_protected) return false;
	if(is_private != that->is_private) return false;
	if(is_static != that->is_static) return false;
	if(is_const != that->is_const) return false;
	
	return true;
}

void AST_attr_mod::replace_wildcards(Object* pattern)
{
	AST_attr_mod* that = dynamic_cast<AST_attr_mod*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}

AST_attr_mod* AST_attr_mod::transform(Tree_transform* transform)
{
	AST_attr_mod* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_attr_mod* AST_attr_mod::pre_transform(Tree_transform* transform)
{
	return transform->pre_attr_mod(this);
}

void AST_attr_mod::transform_children(Tree_transform* transform)
{
	transform->children_attr_mod(this);
}

AST_attr_mod* AST_attr_mod::post_transform(Tree_transform* transform)
{
	return transform->post_attr_mod(this);
}

void AST_attr_mod::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_attr_mod::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_attr_mod(this);
}

void AST_attr_mod::visit_children(Tree_visitor* visitor)
{
	visitor->children_attr_mod(this);
}

void AST_attr_mod::post_visit(Tree_visitor* visitor)
{
	visitor->post_attr_mod(this);
	visitor->post_node(this);
}

AST_attr_mod* AST_attr_mod::new_PUBLIC()
{
	return new AST_attr_mod(true, false, false, false, false);
}

AST_attr_mod* AST_attr_mod::new_PROTECTED()
{
	return new AST_attr_mod(false, true, false, false, false);
}

AST_attr_mod* AST_attr_mod::new_PRIVATE()
{
	return new AST_attr_mod(false, false, true, false, false);
}

AST_attr_mod* AST_attr_mod::new_STATIC()
{
	return new AST_attr_mod(false, false, false, true, false);
}

AST_attr_mod* AST_attr_mod::new_CONST()
{
	return new AST_attr_mod(false, false, false, false, true);
}

AST_directive::AST_directive()
{
}

AST_directive::AST_directive(Token_directive_name* directive_name, AST_expr* expr)
{
	this->directive_name = directive_name;
	this->expr = expr;
}

bool AST_directive::deep_equals(Object* other)
{
	AST_directive* that = dynamic_cast<AST_directive*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(directive_name == NULL)
		{ if(that->directive_name != NULL) return false; }
	else
		{ if(!directive_name->deep_equals(that->directive_name)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_directive* AST_directive::deep_clone(Object* partial_result)
{
	AST_directive* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_directive*>(partial_result);
	else
		clone = new AST_directive();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	if(directive_name)
		clone->directive_name = directive_name->deep_clone();
	else
		clone->directive_name = NULL;
	assert(!directive_name || clone->directive_name);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_directive::try_match(Object* pattern)
{
	AST_directive* that = dynamic_cast<AST_directive*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->directive_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(directive_name == NULL)
		{ if(that->directive_name != NULL) return false; }
	else
		{ if(!directive_name->try_match(that->directive_name)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_directive::replace_wildcards(Object* pattern)
{
	AST_directive* that = dynamic_cast<AST_directive*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->directive_name) == dynamic_cast<void*>(WILDCARD))
		{ that->directive_name = directive_name; }
	else if(directive_name != NULL)
		{ directive_name->replace_wildcards(that->directive_name); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_directive_list* AST_directive::transform(Tree_transform* transform)
{
	AST_directive_list* node = pre_transform(transform);
	AST_directive_list::const_iterator i;
	AST_directive_list* new_v = new AST_directive_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_directive_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_directive_list* AST_directive::pre_transform(Tree_transform* transform)
{
	AST_directive_list* new_v = new AST_directive_list;
	transform->pre_directive(this, new_v);
	return new_v;
}

void AST_directive::transform_children(Tree_transform* transform)
{
	transform->children_directive(this);
}

AST_directive_list* AST_directive::post_transform(Tree_transform* transform)
{
	AST_directive_list* new_v = new AST_directive_list;
	transform->post_directive(this, new_v);
	return new_v;
}

void AST_directive::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_directive::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_directive(this);
}

void AST_directive::visit_children(Tree_visitor* visitor)
{
	visitor->children_directive(this);
}

void AST_directive::post_visit(Tree_visitor* visitor)
{
	visitor->post_directive(this);
	visitor->post_node(this);
}

bool AST_list_element::deep_equals(Object* other)
{
	AST_list_element* that = dynamic_cast<AST_list_element*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_list_element* AST_list_element::deep_clone(Object* partial_result)
{
	// abstract class
	AST_list_element* clone = dynamic_cast<AST_list_element*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_list_element::try_match(Object* pattern)
{
	AST_list_element* that = dynamic_cast<AST_list_element*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_list_element::replace_wildcards(Object* pattern)
{
	AST_list_element* that = dynamic_cast<AST_list_element*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









bool AST_variable_name::deep_equals(Object* other)
{
	AST_variable_name* that = dynamic_cast<AST_variable_name*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_variable_name* AST_variable_name::deep_clone(Object* partial_result)
{
	// abstract class
	AST_variable_name* clone = dynamic_cast<AST_variable_name*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_variable_name::try_match(Object* pattern)
{
	AST_variable_name* that = dynamic_cast<AST_variable_name*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_variable_name::replace_wildcards(Object* pattern)
{
	AST_variable_name* that = dynamic_cast<AST_variable_name*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









bool AST_target::deep_equals(Object* other)
{
	AST_target* that = dynamic_cast<AST_target*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_target* AST_target::deep_clone(Object* partial_result)
{
	// abstract class
	AST_target* clone = dynamic_cast<AST_target*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_target::try_match(Object* pattern)
{
	AST_target* that = dynamic_cast<AST_target*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_target::replace_wildcards(Object* pattern)
{
	AST_target* that = dynamic_cast<AST_target*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









AST_array_elem::AST_array_elem()
{
}

AST_array_elem::AST_array_elem(AST_expr* key, bool is_ref, AST_expr* val)
{
	this->key = key;
	this->is_ref = is_ref;
	this->val = val;
}

bool AST_array_elem::deep_equals(Object* other)
{
	AST_array_elem* that = dynamic_cast<AST_array_elem*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(key == NULL)
		{ if(that->key != NULL) return false; }
	else
		{ if(!key->deep_equals(that->key)) return false; }
	if(is_ref != that->is_ref) return false;
	if(val == NULL)
		{ if(that->val != NULL) return false; }
	else
		{ if(!val->deep_equals(that->val)) return false; }
	
	return true;
}

AST_array_elem* AST_array_elem::deep_clone(Object* partial_result)
{
	AST_array_elem* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_array_elem*>(partial_result);
	else
		clone = new AST_array_elem();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	if(key)
		clone->key = key->deep_clone();
	else
		clone->key = NULL;
	assert(!key || clone->key);
	
	clone->is_ref = is_ref;
	
	if(val)
		clone->val = val->deep_clone();
	else
		clone->val = NULL;
	assert(!val || clone->val);
	
	return clone;
}

bool AST_array_elem::try_match(Object* pattern)
{
	AST_array_elem* that = dynamic_cast<AST_array_elem*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->key) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(key == NULL)
		{ if(that->key != NULL) return false; }
	else
		{ if(!key->try_match(that->key)) return false; }
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->val) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(val == NULL)
		{ if(that->val != NULL) return false; }
	else
		{ if(!val->try_match(that->val)) return false; }
	
	return true;
}

void AST_array_elem::replace_wildcards(Object* pattern)
{
	AST_array_elem* that = dynamic_cast<AST_array_elem*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->key) == dynamic_cast<void*>(WILDCARD))
		{ that->key = key; }
	else if(key != NULL)
		{ key->replace_wildcards(that->key); }
	if(dynamic_cast<void*>(that->val) == dynamic_cast<void*>(WILDCARD))
		{ that->val = val; }
	else if(val != NULL)
		{ val->replace_wildcards(that->val); }
}

AST_array_elem_list* AST_array_elem::transform(Tree_transform* transform)
{
	AST_array_elem_list* node = pre_transform(transform);
	AST_array_elem_list::const_iterator i;
	AST_array_elem_list* new_v = new AST_array_elem_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_array_elem_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_array_elem_list* AST_array_elem::pre_transform(Tree_transform* transform)
{
	AST_array_elem_list* new_v = new AST_array_elem_list;
	transform->pre_array_elem(this, new_v);
	return new_v;
}

void AST_array_elem::transform_children(Tree_transform* transform)
{
	transform->children_array_elem(this);
}

AST_array_elem_list* AST_array_elem::post_transform(Tree_transform* transform)
{
	AST_array_elem_list* new_v = new AST_array_elem_list;
	transform->post_array_elem(this, new_v);
	return new_v;
}

void AST_array_elem::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_array_elem::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_array_elem(this);
}

void AST_array_elem::visit_children(Tree_visitor* visitor)
{
	visitor->children_array_elem(this);
}

void AST_array_elem::post_visit(Tree_visitor* visitor)
{
	visitor->post_array_elem(this);
	visitor->post_node(this);
}

bool AST_method_name::deep_equals(Object* other)
{
	AST_method_name* that = dynamic_cast<AST_method_name*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_method_name* AST_method_name::deep_clone(Object* partial_result)
{
	// abstract class
	AST_method_name* clone = dynamic_cast<AST_method_name*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_method_name::try_match(Object* pattern)
{
	AST_method_name* that = dynamic_cast<AST_method_name*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_method_name::replace_wildcards(Object* pattern)
{
	AST_method_name* that = dynamic_cast<AST_method_name*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









AST_actual_parameter::AST_actual_parameter()
{
}

AST_actual_parameter::AST_actual_parameter(bool is_ref, AST_expr* expr)
{
	this->is_ref = is_ref;
	this->expr = expr;
}

bool AST_actual_parameter::deep_equals(Object* other)
{
	AST_actual_parameter* that = dynamic_cast<AST_actual_parameter*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	if(is_ref != that->is_ref) return false;
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_actual_parameter* AST_actual_parameter::deep_clone(Object* partial_result)
{
	AST_actual_parameter* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_actual_parameter*>(partial_result);
	else
		clone = new AST_actual_parameter();
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	clone->is_ref = is_ref;
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_actual_parameter::try_match(Object* pattern)
{
	AST_actual_parameter* that = dynamic_cast<AST_actual_parameter*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_actual_parameter::replace_wildcards(Object* pattern)
{
	AST_actual_parameter* that = dynamic_cast<AST_actual_parameter*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_actual_parameter_list* AST_actual_parameter::transform(Tree_transform* transform)
{
	AST_actual_parameter_list* node = pre_transform(transform);
	AST_actual_parameter_list::const_iterator i;
	AST_actual_parameter_list* new_v = new AST_actual_parameter_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_actual_parameter_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_actual_parameter_list* AST_actual_parameter::pre_transform(Tree_transform* transform)
{
	AST_actual_parameter_list* new_v = new AST_actual_parameter_list;
	transform->pre_actual_parameter(this, new_v);
	return new_v;
}

void AST_actual_parameter::transform_children(Tree_transform* transform)
{
	transform->children_actual_parameter(this);
}

AST_actual_parameter_list* AST_actual_parameter::post_transform(Tree_transform* transform)
{
	AST_actual_parameter_list* new_v = new AST_actual_parameter_list;
	transform->post_actual_parameter(this, new_v);
	return new_v;
}

void AST_actual_parameter::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_actual_parameter::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_actual_parameter(this);
}

void AST_actual_parameter::visit_children(Tree_visitor* visitor)
{
	visitor->children_actual_parameter(this);
}

void AST_actual_parameter::post_visit(Tree_visitor* visitor)
{
	visitor->post_actual_parameter(this);
	visitor->post_node(this);
}

bool AST_class_name::deep_equals(Object* other)
{
	AST_class_name* that = dynamic_cast<AST_class_name*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_class_name* AST_class_name::deep_clone(Object* partial_result)
{
	// abstract class
	AST_class_name* clone = dynamic_cast<AST_class_name*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_class_name::try_match(Object* pattern)
{
	AST_class_name* that = dynamic_cast<AST_class_name*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_class_name::replace_wildcards(Object* pattern)
{
	AST_class_name* that = dynamic_cast<AST_class_name*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









AST_commented_node::AST_commented_node()
{
	attrs->set("phc.comments", new List<String*>);
}

bool AST_commented_node::deep_equals(Object* other)
{
	AST_commented_node* that = dynamic_cast<AST_commented_node*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_commented_node* AST_commented_node::deep_clone(Object* partial_result)
{
	// abstract class
	AST_commented_node* clone = dynamic_cast<AST_commented_node*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_commented_node::try_match(Object* pattern)
{
	AST_commented_node* that = dynamic_cast<AST_commented_node*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_commented_node::replace_wildcards(Object* pattern)
{
	AST_commented_node* that = dynamic_cast<AST_commented_node*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}









List<String*>* AST_commented_node::get_comments()
{
	List<String*>* comments = dynamic_cast<List<String*>*>(attrs->get("phc.comments"));
	assert(comments);
	return comments;
}

bool AST_identifier::deep_equals(Object* other)
{
	AST_identifier* that = dynamic_cast<AST_identifier*>(other);
	if(!that) return false;
	
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_identifier* AST_identifier::deep_clone(Object* partial_result)
{
	// abstract class
	AST_identifier* clone = dynamic_cast<AST_identifier*>(partial_result);
	assert(clone);
	
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_identifier::try_match(Object* pattern)
{
	AST_identifier* that = dynamic_cast<AST_identifier*>(pattern);
	if(!that) return false;
	
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_identifier::replace_wildcards(Object* pattern)
{
	AST_identifier* that = dynamic_cast<AST_identifier*>(pattern);
	assert(that);
	
	AST_node::replace_wildcards(that);
	
}










bool AST_interface_def_list::deep_equals(Object* other)
{
	AST_interface_def_list* that = dynamic_cast<AST_interface_def_list*>(other);
	if(!that) return false;
	
	if(!List<AST_interface_def*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_interface_def_list* AST_interface_def_list::deep_clone(Object* partial_result)
{
	AST_interface_def_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_interface_def_list*>(partial_result);
	else
		clone = new AST_interface_def_list();
	assert(clone);
	
	List<AST_interface_def*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_interface_def_list::try_match(Object* pattern)
{
	AST_interface_def_list* that = dynamic_cast<AST_interface_def_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_interface_def*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_interface_def_list::replace_wildcards(Object* pattern)
{
	AST_interface_def_list* that = dynamic_cast<AST_interface_def_list*>(pattern);
	assert(that);
	
	List<AST_interface_def*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_interface_def_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_interface_def_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_interface_def_list(this);
}

void AST_interface_def_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_interface_def_list(this);
}

void AST_interface_def_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_interface_def_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_interface_def_list* AST_interface_def_list::transform(Tree_transform* transform)
{
	AST_interface_def_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_interface_def_list* AST_interface_def_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_interface_def_list(this);
}

void AST_interface_def_list::transform_children(Tree_transform* transform)
{
	transform->children_interface_def_list(this);
}

AST_interface_def_list* AST_interface_def_list::post_transform(Tree_transform* transform)
{
	return transform->post_interface_def_list(this);
}

bool AST_class_def_list::deep_equals(Object* other)
{
	AST_class_def_list* that = dynamic_cast<AST_class_def_list*>(other);
	if(!that) return false;
	
	if(!List<AST_class_def*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_class_def_list* AST_class_def_list::deep_clone(Object* partial_result)
{
	AST_class_def_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_class_def_list*>(partial_result);
	else
		clone = new AST_class_def_list();
	assert(clone);
	
	List<AST_class_def*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_class_def_list::try_match(Object* pattern)
{
	AST_class_def_list* that = dynamic_cast<AST_class_def_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_class_def*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_class_def_list::replace_wildcards(Object* pattern)
{
	AST_class_def_list* that = dynamic_cast<AST_class_def_list*>(pattern);
	assert(that);
	
	List<AST_class_def*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_class_def_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_class_def_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_class_def_list(this);
}

void AST_class_def_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_class_def_list(this);
}

void AST_class_def_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_class_def_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_class_def_list* AST_class_def_list::transform(Tree_transform* transform)
{
	AST_class_def_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_class_def_list* AST_class_def_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_class_def_list(this);
}

void AST_class_def_list::transform_children(Tree_transform* transform)
{
	transform->children_class_def_list(this);
}

AST_class_def_list* AST_class_def_list::post_transform(Tree_transform* transform)
{
	return transform->post_class_def_list(this);
}

bool AST_member_list::deep_equals(Object* other)
{
	AST_member_list* that = dynamic_cast<AST_member_list*>(other);
	if(!that) return false;
	
	if(!List<AST_member*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_member_list* AST_member_list::deep_clone(Object* partial_result)
{
	AST_member_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_member_list*>(partial_result);
	else
		clone = new AST_member_list();
	assert(clone);
	
	List<AST_member*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_member_list::try_match(Object* pattern)
{
	AST_member_list* that = dynamic_cast<AST_member_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_member*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_member_list::replace_wildcards(Object* pattern)
{
	AST_member_list* that = dynamic_cast<AST_member_list*>(pattern);
	assert(that);
	
	List<AST_member*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_member_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_member_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_member_list(this);
}

void AST_member_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_member_list(this);
}

void AST_member_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_member_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_member_list* AST_member_list::transform(Tree_transform* transform)
{
	AST_member_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_member_list* AST_member_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_member_list(this);
}

void AST_member_list::transform_children(Tree_transform* transform)
{
	transform->children_member_list(this);
}

AST_member_list* AST_member_list::post_transform(Tree_transform* transform)
{
	return transform->post_member_list(this);
}

bool AST_statement_list::deep_equals(Object* other)
{
	AST_statement_list* that = dynamic_cast<AST_statement_list*>(other);
	if(!that) return false;
	
	if(!List<AST_statement*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_statement_list* AST_statement_list::deep_clone(Object* partial_result)
{
	AST_statement_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_statement_list*>(partial_result);
	else
		clone = new AST_statement_list();
	assert(clone);
	
	List<AST_statement*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_statement_list::try_match(Object* pattern)
{
	AST_statement_list* that = dynamic_cast<AST_statement_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_statement*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_statement_list::replace_wildcards(Object* pattern)
{
	AST_statement_list* that = dynamic_cast<AST_statement_list*>(pattern);
	assert(that);
	
	List<AST_statement*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_statement_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_statement_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement_list(this);
}

void AST_statement_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_statement_list(this);
}

void AST_statement_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_statement_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_statement_list* AST_statement_list::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_statement_list* AST_statement_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_statement_list(this);
}

void AST_statement_list::transform_children(Tree_transform* transform)
{
	transform->children_statement_list(this);
}

AST_statement_list* AST_statement_list::post_transform(Tree_transform* transform)
{
	return transform->post_statement_list(this);
}

bool AST_switch_case_list::deep_equals(Object* other)
{
	AST_switch_case_list* that = dynamic_cast<AST_switch_case_list*>(other);
	if(!that) return false;
	
	if(!List<AST_switch_case*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_switch_case_list* AST_switch_case_list::deep_clone(Object* partial_result)
{
	AST_switch_case_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_switch_case_list*>(partial_result);
	else
		clone = new AST_switch_case_list();
	assert(clone);
	
	List<AST_switch_case*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_switch_case_list::try_match(Object* pattern)
{
	AST_switch_case_list* that = dynamic_cast<AST_switch_case_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_switch_case*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_switch_case_list::replace_wildcards(Object* pattern)
{
	AST_switch_case_list* that = dynamic_cast<AST_switch_case_list*>(pattern);
	assert(that);
	
	List<AST_switch_case*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_switch_case_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_switch_case_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_switch_case_list(this);
}

void AST_switch_case_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_switch_case_list(this);
}

void AST_switch_case_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_switch_case_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_switch_case_list* AST_switch_case_list::transform(Tree_transform* transform)
{
	AST_switch_case_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_switch_case_list* AST_switch_case_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_switch_case_list(this);
}

void AST_switch_case_list::transform_children(Tree_transform* transform)
{
	transform->children_switch_case_list(this);
}

AST_switch_case_list* AST_switch_case_list::post_transform(Tree_transform* transform)
{
	return transform->post_switch_case_list(this);
}

bool AST_catch_list::deep_equals(Object* other)
{
	AST_catch_list* that = dynamic_cast<AST_catch_list*>(other);
	if(!that) return false;
	
	if(!List<AST_catch*>::deep_equals(that)) return false;
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_catch_list* AST_catch_list::deep_clone(Object* partial_result)
{
	AST_catch_list* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_catch_list*>(partial_result);
	else
		clone = new AST_catch_list();
	assert(clone);
	
	List<AST_catch*>::deep_clone(clone);
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_catch_list::try_match(Object* pattern)
{
	AST_catch_list* that = dynamic_cast<AST_catch_list*>(pattern);
	if(!that) return false;
	
	if(!List<AST_catch*>::try_match(that)) return false;
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_catch_list::replace_wildcards(Object* pattern)
{
	AST_catch_list* that = dynamic_cast<AST_catch_list*>(pattern);
	assert(that);
	
	List<AST_catch*>::replace_wildcards(that);
	AST_commented_node::replace_wildcards(that);
	
}

void AST_catch_list::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_catch_list::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_catch_list(this);
}

void AST_catch_list::visit_children(Tree_visitor* visitor)
{
	visitor->children_catch_list(this);
}

void AST_catch_list::post_visit(Tree_visitor* visitor)
{
	visitor->post_catch_list(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_catch_list* AST_catch_list::transform(Tree_transform* transform)
{
	AST_catch_list* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_catch_list* AST_catch_list::pre_transform(Tree_transform* transform)
{
	return transform->pre_catch_list(this);
}

void AST_catch_list::transform_children(Tree_transform* transform)
{
	transform->children_catch_list(this);
}

AST_catch_list* AST_catch_list::post_transform(Tree_transform* transform)
{
	return transform->post_catch_list(this);
}

AST_interface_def::AST_interface_def()
{
}

AST_interface_def::AST_interface_def(Token_interface_name* interface_name, Token_interface_name_list* extends, AST_member_list* members)
{
	this->interface_name = interface_name;
	this->extends = extends;
	this->members = members;
}

bool AST_interface_def::deep_equals(Object* other)
{
	AST_interface_def* that = dynamic_cast<AST_interface_def*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	if(interface_name == NULL)
		{ if(that->interface_name != NULL) return false; }
	else
		{ if(!interface_name->deep_equals(that->interface_name)) return false; }
	if(extends == NULL)
		{ if(that->extends != NULL) return false; }
	else
		{ if(!extends->deep_equals(that->extends)) return false; }
	if(members == NULL)
		{ if(that->members != NULL) return false; }
	else
		{ if(!members->deep_equals(that->members)) return false; }
	
	return true;
}

AST_interface_def* AST_interface_def::deep_clone(Object* partial_result)
{
	AST_interface_def* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_interface_def*>(partial_result);
	else
		clone = new AST_interface_def();
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	if(interface_name)
		clone->interface_name = interface_name->deep_clone();
	else
		clone->interface_name = NULL;
	assert(!interface_name || clone->interface_name);
	
	if(extends)
		clone->extends = extends->deep_clone();
	else
		clone->extends = NULL;
	assert(!extends || clone->extends);
	
	if(members)
		clone->members = members->deep_clone();
	else
		clone->members = NULL;
	assert(!members || clone->members);
	
	return clone;
}

bool AST_interface_def::try_match(Object* pattern)
{
	AST_interface_def* that = dynamic_cast<AST_interface_def*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->interface_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(interface_name == NULL)
		{ if(that->interface_name != NULL) return false; }
	else
		{ if(!interface_name->try_match(that->interface_name)) return false; }
	if(dynamic_cast<void*>(that->extends) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(extends == NULL)
		{ if(that->extends != NULL) return false; }
	else
		{ if(!extends->try_match(that->extends)) return false; }
	if(dynamic_cast<void*>(that->members) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(members == NULL)
		{ if(that->members != NULL) return false; }
	else
		{ if(!members->try_match(that->members)) return false; }
	
	return true;
}

void AST_interface_def::replace_wildcards(Object* pattern)
{
	AST_interface_def* that = dynamic_cast<AST_interface_def*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->interface_name) == dynamic_cast<void*>(WILDCARD))
		{ that->interface_name = interface_name; }
	else if(interface_name != NULL)
		{ interface_name->replace_wildcards(that->interface_name); }
	if(dynamic_cast<void*>(that->extends) == dynamic_cast<void*>(WILDCARD))
		{ that->extends = extends; }
	else if(extends != NULL)
		{ extends->replace_wildcards(that->extends); }
	if(dynamic_cast<void*>(that->members) == dynamic_cast<void*>(WILDCARD))
		{ that->members = members; }
	else if(members != NULL)
		{ members->replace_wildcards(that->members); }
}

AST_interface_def_list* AST_interface_def::transform(Tree_transform* transform)
{
	AST_interface_def_list* node = pre_transform(transform);
	AST_interface_def_list::const_iterator i;
	AST_interface_def_list* new_v = new AST_interface_def_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_interface_def_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_interface_def_list* AST_interface_def::pre_transform(Tree_transform* transform)
{
	AST_interface_def_list* new_v = new AST_interface_def_list;
	transform->pre_interface_def(this, new_v);
	return new_v;
}

void AST_interface_def::transform_children(Tree_transform* transform)
{
	transform->children_interface_def(this);
}

AST_interface_def_list* AST_interface_def::post_transform(Tree_transform* transform)
{
	AST_interface_def_list* new_v = new AST_interface_def_list;
	transform->post_interface_def(this, new_v);
	return new_v;
}

void AST_interface_def::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_interface_def::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_interface_def(this);
}

void AST_interface_def::visit_children(Tree_visitor* visitor)
{
	visitor->children_interface_def(this);
}

void AST_interface_def::post_visit(Tree_visitor* visitor)
{
	visitor->post_interface_def(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_class_def::AST_class_def()
{
}

AST_class_def::AST_class_def(AST_class_mod* class_mod, Token_class_name* class_name, Token_class_name* extends, Token_interface_name_list* implements, AST_member_list* members)
{
	this->class_mod = class_mod;
	this->class_name = class_name;
	this->extends = extends;
	this->implements = implements;
	this->members = members;
}

AST_class_def::AST_class_def(AST_class_mod* mod)
{
	this->class_mod = mod;
	this->class_name = NULL;
	this->extends = NULL;
	this->implements = new Token_interface_name_list;
	this->members = new AST_member_list;
}

AST_class_def::AST_class_def(char* name)
{
	this->class_mod = new AST_class_mod(false, false);
	this->class_name = new Token_class_name(new String(name));
	this->extends = NULL;
	this->implements = new Token_interface_name_list;
	this->members = new AST_member_list;
}

bool AST_class_def::deep_equals(Object* other)
{
	AST_class_def* that = dynamic_cast<AST_class_def*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	if(class_mod == NULL)
		{ if(that->class_mod != NULL) return false; }
	else
		{ if(!class_mod->deep_equals(that->class_mod)) return false; }
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	if(extends == NULL)
		{ if(that->extends != NULL) return false; }
	else
		{ if(!extends->deep_equals(that->extends)) return false; }
	if(implements == NULL)
		{ if(that->implements != NULL) return false; }
	else
		{ if(!implements->deep_equals(that->implements)) return false; }
	if(members == NULL)
		{ if(that->members != NULL) return false; }
	else
		{ if(!members->deep_equals(that->members)) return false; }
	
	return true;
}

AST_class_def* AST_class_def::deep_clone(Object* partial_result)
{
	AST_class_def* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_class_def*>(partial_result);
	else
		clone = new AST_class_def();
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	if(class_mod)
		clone->class_mod = class_mod->deep_clone();
	else
		clone->class_mod = NULL;
	assert(!class_mod || clone->class_mod);
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	if(extends)
		clone->extends = extends->deep_clone();
	else
		clone->extends = NULL;
	assert(!extends || clone->extends);
	
	if(implements)
		clone->implements = implements->deep_clone();
	else
		clone->implements = NULL;
	assert(!implements || clone->implements);
	
	if(members)
		clone->members = members->deep_clone();
	else
		clone->members = NULL;
	assert(!members || clone->members);
	
	return clone;
}

bool AST_class_def::try_match(Object* pattern)
{
	AST_class_def* that = dynamic_cast<AST_class_def*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->class_mod) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_mod == NULL)
		{ if(that->class_mod != NULL) return false; }
	else
		{ if(!class_mod->try_match(that->class_mod)) return false; }
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	if(dynamic_cast<void*>(that->extends) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(extends == NULL)
		{ if(that->extends != NULL) return false; }
	else
		{ if(!extends->try_match(that->extends)) return false; }
	if(dynamic_cast<void*>(that->implements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(implements == NULL)
		{ if(that->implements != NULL) return false; }
	else
		{ if(!implements->try_match(that->implements)) return false; }
	if(dynamic_cast<void*>(that->members) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(members == NULL)
		{ if(that->members != NULL) return false; }
	else
		{ if(!members->try_match(that->members)) return false; }
	
	return true;
}

void AST_class_def::replace_wildcards(Object* pattern)
{
	AST_class_def* that = dynamic_cast<AST_class_def*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->class_mod) == dynamic_cast<void*>(WILDCARD))
		{ that->class_mod = class_mod; }
	else if(class_mod != NULL)
		{ class_mod->replace_wildcards(that->class_mod); }
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
	if(dynamic_cast<void*>(that->extends) == dynamic_cast<void*>(WILDCARD))
		{ that->extends = extends; }
	else if(extends != NULL)
		{ extends->replace_wildcards(that->extends); }
	if(dynamic_cast<void*>(that->implements) == dynamic_cast<void*>(WILDCARD))
		{ that->implements = implements; }
	else if(implements != NULL)
		{ implements->replace_wildcards(that->implements); }
	if(dynamic_cast<void*>(that->members) == dynamic_cast<void*>(WILDCARD))
		{ that->members = members; }
	else if(members != NULL)
		{ members->replace_wildcards(that->members); }
}

AST_class_def_list* AST_class_def::transform(Tree_transform* transform)
{
	AST_class_def_list* node = pre_transform(transform);
	AST_class_def_list::const_iterator i;
	AST_class_def_list* new_v = new AST_class_def_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_class_def_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_class_def_list* AST_class_def::pre_transform(Tree_transform* transform)
{
	AST_class_def_list* new_v = new AST_class_def_list;
	transform->pre_class_def(this, new_v);
	return new_v;
}

void AST_class_def::transform_children(Tree_transform* transform)
{
	transform->children_class_def(this);
}

AST_class_def_list* AST_class_def::post_transform(Tree_transform* transform)
{
	AST_class_def_list* new_v = new AST_class_def_list;
	transform->post_class_def(this, new_v);
	return new_v;
}

void AST_class_def::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_class_def::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_class_def(this);
}

void AST_class_def::visit_children(Tree_visitor* visitor)
{
	visitor->children_class_def(this);
}

void AST_class_def::post_visit(Tree_visitor* visitor)
{
	visitor->post_class_def(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

void AST_class_def::add_member(AST_member* member)
{
	this->members->push_back(member);
}

AST_method* AST_class_def::get_method(const char* name)
{
	AST_member_list::const_iterator i;
	for(i = members->begin(); i != members->end(); i++)
	{
	AST_method* method = dynamic_cast<AST_method*>(*i);
	if(method && *method->signature->method_name->value == name)
	return method;
	}
	
	return NULL;
}

bool AST_member::deep_equals(Object* other)
{
	AST_member* that = dynamic_cast<AST_member*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_member* AST_member::deep_clone(Object* partial_result)
{
	// abstract class
	AST_member* clone = dynamic_cast<AST_member*>(partial_result);
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_member::try_match(Object* pattern)
{
	AST_member* that = dynamic_cast<AST_member*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_member::replace_wildcards(Object* pattern)
{
	AST_member* that = dynamic_cast<AST_member*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
}









bool AST_statement::deep_equals(Object* other)
{
	AST_statement* that = dynamic_cast<AST_statement*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_statement* AST_statement::deep_clone(Object* partial_result)
{
	// abstract class
	AST_statement* clone = dynamic_cast<AST_statement*>(partial_result);
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	return clone;
}

bool AST_statement::try_match(Object* pattern)
{
	AST_statement* that = dynamic_cast<AST_statement*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	
	return true;
}

void AST_statement::replace_wildcards(Object* pattern)
{
	AST_statement* that = dynamic_cast<AST_statement*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
}









AST_switch_case::AST_switch_case()
{
}

AST_switch_case::AST_switch_case(AST_expr* expr, AST_statement_list* statements)
{
	this->expr = expr;
	this->statements = statements;
}

bool AST_switch_case::deep_equals(Object* other)
{
	AST_switch_case* that = dynamic_cast<AST_switch_case*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_switch_case* AST_switch_case::deep_clone(Object* partial_result)
{
	AST_switch_case* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_switch_case*>(partial_result);
	else
		clone = new AST_switch_case();
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_switch_case::try_match(Object* pattern)
{
	AST_switch_case* that = dynamic_cast<AST_switch_case*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_switch_case::replace_wildcards(Object* pattern)
{
	AST_switch_case* that = dynamic_cast<AST_switch_case*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_switch_case_list* AST_switch_case::transform(Tree_transform* transform)
{
	AST_switch_case_list* node = pre_transform(transform);
	AST_switch_case_list::const_iterator i;
	AST_switch_case_list* new_v = new AST_switch_case_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_switch_case_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_switch_case_list* AST_switch_case::pre_transform(Tree_transform* transform)
{
	AST_switch_case_list* new_v = new AST_switch_case_list;
	transform->pre_switch_case(this, new_v);
	return new_v;
}

void AST_switch_case::transform_children(Tree_transform* transform)
{
	transform->children_switch_case(this);
}

AST_switch_case_list* AST_switch_case::post_transform(Tree_transform* transform)
{
	AST_switch_case_list* new_v = new AST_switch_case_list;
	transform->post_switch_case(this, new_v);
	return new_v;
}

void AST_switch_case::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_switch_case::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_switch_case(this);
}

void AST_switch_case::visit_children(Tree_visitor* visitor)
{
	visitor->children_switch_case(this);
}

void AST_switch_case::post_visit(Tree_visitor* visitor)
{
	visitor->post_switch_case(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_catch::AST_catch()
{
}

AST_catch::AST_catch(Token_class_name* class_name, Token_variable_name* variable_name, AST_statement_list* statements)
{
	this->class_name = class_name;
	this->variable_name = variable_name;
	this->statements = statements;
}

bool AST_catch::deep_equals(Object* other)
{
	AST_catch* that = dynamic_cast<AST_catch*>(other);
	if(!that) return false;
	
	if(!AST_commented_node::deep_equals(that)) return false;
	
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->deep_equals(that->variable_name)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_catch* AST_catch::deep_clone(Object* partial_result)
{
	AST_catch* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_catch*>(partial_result);
	else
		clone = new AST_catch();
	assert(clone);
	
	AST_commented_node::deep_clone(clone);
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	if(variable_name)
		clone->variable_name = variable_name->deep_clone();
	else
		clone->variable_name = NULL;
	assert(!variable_name || clone->variable_name);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_catch::try_match(Object* pattern)
{
	AST_catch* that = dynamic_cast<AST_catch*>(pattern);
	if(!that) return false;
	
	if(!AST_commented_node::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->try_match(that->variable_name)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_catch::replace_wildcards(Object* pattern)
{
	AST_catch* that = dynamic_cast<AST_catch*>(pattern);
	assert(that);
	
	AST_commented_node::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ that->variable_name = variable_name; }
	else if(variable_name != NULL)
		{ variable_name->replace_wildcards(that->variable_name); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_catch_list* AST_catch::transform(Tree_transform* transform)
{
	AST_catch_list* node = pre_transform(transform);
	AST_catch_list::const_iterator i;
	AST_catch_list* new_v = new AST_catch_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_catch_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_catch_list* AST_catch::pre_transform(Tree_transform* transform)
{
	AST_catch_list* new_v = new AST_catch_list;
	transform->pre_catch(this, new_v);
	return new_v;
}

void AST_catch::transform_children(Tree_transform* transform)
{
	transform->children_catch(this);
}

AST_catch_list* AST_catch::post_transform(Tree_transform* transform)
{
	AST_catch_list* new_v = new AST_catch_list;
	transform->post_catch(this, new_v);
	return new_v;
}

void AST_catch::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_catch::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_catch(this);
}

void AST_catch::visit_children(Tree_visitor* visitor)
{
	visitor->children_catch(this);
}

void AST_catch::post_visit(Tree_visitor* visitor)
{
	visitor->post_catch(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_expr::AST_expr()
{
	attrs->set("phc.unparser.needs_brackets", new Boolean(false));
}

bool AST_expr::deep_equals(Object* other)
{
	AST_expr* that = dynamic_cast<AST_expr*>(other);
	if(!that) return false;
	
	if(!AST_target::deep_equals(that)) return false;
	if(!AST_node::deep_equals(that)) return false;
	
	
	return true;
}

AST_expr* AST_expr::deep_clone(Object* partial_result)
{
	// abstract class
	AST_expr* clone = dynamic_cast<AST_expr*>(partial_result);
	assert(clone);
	
	AST_target::deep_clone(clone);
	AST_node::deep_clone(clone);
	
	return clone;
}

bool AST_expr::try_match(Object* pattern)
{
	AST_expr* that = dynamic_cast<AST_expr*>(pattern);
	if(!that) return false;
	
	if(!AST_target::try_match(that)) return false;
	if(!AST_node::try_match(that)) return false;
	
	
	return true;
}

void AST_expr::replace_wildcards(Object* pattern)
{
	AST_expr* that = dynamic_cast<AST_expr*>(pattern);
	assert(that);
	
	AST_target::replace_wildcards(that);
	AST_node::replace_wildcards(that);
	
}









AST_list_elements::AST_list_elements()
{
}

AST_list_elements::AST_list_elements(AST_list_element_list* list_elements)
{
	this->list_elements = list_elements;
}

bool AST_list_elements::deep_equals(Object* other)
{
	AST_list_elements* that = dynamic_cast<AST_list_elements*>(other);
	if(!that) return false;
	
	if(!AST_list_element::deep_equals(that)) return false;
	
	if(list_elements == NULL)
		{ if(that->list_elements != NULL) return false; }
	else
		{ if(!list_elements->deep_equals(that->list_elements)) return false; }
	
	return true;
}

AST_list_elements* AST_list_elements::deep_clone(Object* partial_result)
{
	AST_list_elements* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_list_elements*>(partial_result);
	else
		clone = new AST_list_elements();
	assert(clone);
	
	AST_list_element::deep_clone(clone);
	
	if(list_elements)
		clone->list_elements = list_elements->deep_clone();
	else
		clone->list_elements = NULL;
	assert(!list_elements || clone->list_elements);
	
	return clone;
}

bool AST_list_elements::try_match(Object* pattern)
{
	AST_list_elements* that = dynamic_cast<AST_list_elements*>(pattern);
	if(!that) return false;
	
	if(!AST_list_element::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->list_elements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(list_elements == NULL)
		{ if(that->list_elements != NULL) return false; }
	else
		{ if(!list_elements->try_match(that->list_elements)) return false; }
	
	return true;
}

void AST_list_elements::replace_wildcards(Object* pattern)
{
	AST_list_elements* that = dynamic_cast<AST_list_elements*>(pattern);
	assert(that);
	
	AST_list_element::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->list_elements) == dynamic_cast<void*>(WILDCARD))
		{ that->list_elements = list_elements; }
	else if(list_elements != NULL)
		{ list_elements->replace_wildcards(that->list_elements); }
}

AST_list_elements* AST_list_elements::transform(Tree_transform* transform)
{
	AST_list_elements* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_list_elements* AST_list_elements::pre_transform(Tree_transform* transform)
{
	return transform->pre_list_elements(this);
}

void AST_list_elements::transform_children(Tree_transform* transform)
{
	transform->children_list_elements(this);
}

AST_list_elements* AST_list_elements::post_transform(Tree_transform* transform)
{
	return transform->post_list_elements(this);
}

void AST_list_elements::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_list_elements::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_list_element(this);
	visitor->pre_list_elements(this);
}

void AST_list_elements::visit_children(Tree_visitor* visitor)
{
	visitor->children_list_elements(this);
}

void AST_list_elements::post_visit(Tree_visitor* visitor)
{
	visitor->post_list_elements(this);
	visitor->post_list_element(this);
	visitor->post_node(this);
}

AST_reflection::AST_reflection()
{
}

AST_reflection::AST_reflection(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_reflection::deep_equals(Object* other)
{
	AST_reflection* that = dynamic_cast<AST_reflection*>(other);
	if(!that) return false;
	
	if(!AST_variable_name::deep_equals(that)) return false;
	if(!AST_method_name::deep_equals(that)) return false;
	if(!AST_class_name::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_reflection* AST_reflection::deep_clone(Object* partial_result)
{
	AST_reflection* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_reflection*>(partial_result);
	else
		clone = new AST_reflection();
	assert(clone);
	
	AST_variable_name::deep_clone(clone);
	AST_method_name::deep_clone(clone);
	AST_class_name::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_reflection::try_match(Object* pattern)
{
	AST_reflection* that = dynamic_cast<AST_reflection*>(pattern);
	if(!that) return false;
	
	if(!AST_variable_name::try_match(that)) return false;
	if(!AST_method_name::try_match(that)) return false;
	if(!AST_class_name::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_reflection::replace_wildcards(Object* pattern)
{
	AST_reflection* that = dynamic_cast<AST_reflection*>(pattern);
	assert(that);
	
	AST_variable_name::replace_wildcards(that);
	AST_method_name::replace_wildcards(that);
	AST_class_name::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_reflection* AST_reflection::transform(Tree_transform* transform)
{
	AST_reflection* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_reflection* AST_reflection::pre_transform(Tree_transform* transform)
{
	return transform->pre_reflection(this);
}

void AST_reflection::transform_children(Tree_transform* transform)
{
	transform->children_reflection(this);
}

AST_reflection* AST_reflection::post_transform(Tree_transform* transform)
{
	return transform->post_reflection(this);
}

void AST_reflection::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_reflection::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_class_name(this);
	visitor->pre_method_name(this);
	visitor->pre_variable_name(this);
	visitor->pre_reflection(this);
}

void AST_reflection::visit_children(Tree_visitor* visitor)
{
	visitor->children_reflection(this);
}

void AST_reflection::post_visit(Tree_visitor* visitor)
{
	visitor->post_reflection(this);
	visitor->post_variable_name(this);
	visitor->post_method_name(this);
	visitor->post_class_name(this);
	visitor->post_node(this);
}

Token_interface_name::Token_interface_name()
{
}

Token_interface_name::Token_interface_name(String* value)
{
	this->value = value;
}

bool Token_interface_name::deep_equals(Object* other)
{
	Token_interface_name* that = dynamic_cast<Token_interface_name*>(other);
	if(!that) return false;
	
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_interface_name* Token_interface_name::deep_clone(Object* partial_result)
{
	Token_interface_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_interface_name*>(partial_result);
	else
		clone = new Token_interface_name();
	assert(clone);
	
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_interface_name::try_match(Object* pattern)
{
	Token_interface_name* that = dynamic_cast<Token_interface_name*>(pattern);
	if(!that) return false;
	
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_interface_name::replace_wildcards(Object* pattern)
{
	Token_interface_name* that = dynamic_cast<Token_interface_name*>(pattern);
	assert(that);
	
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_interface_name::get_value_as_string()
{
	return value;
}

Token_interface_name* Token_interface_name::transform(Tree_transform* transform)
{
	Token_interface_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_interface_name* Token_interface_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_interface_name(this);
}

void Token_interface_name::transform_children(Tree_transform* transform)
{
	transform->children_interface_name(this);
}

Token_interface_name* Token_interface_name::post_transform(Tree_transform* transform)
{
	return transform->post_interface_name(this);
}

void Token_interface_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_interface_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_interface_name(this);
}

void Token_interface_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_interface_name(this);
}

void Token_interface_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_interface_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_class_name::Token_class_name()
{
}

Token_class_name::Token_class_name(String* value)
{
	this->value = value;
}

bool Token_class_name::deep_equals(Object* other)
{
	Token_class_name* that = dynamic_cast<Token_class_name*>(other);
	if(!that) return false;
	
	if(!AST_target::deep_equals(that)) return false;
	if(!AST_class_name::deep_equals(that)) return false;
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_class_name* Token_class_name::deep_clone(Object* partial_result)
{
	Token_class_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_class_name*>(partial_result);
	else
		clone = new Token_class_name();
	assert(clone);
	
	AST_target::deep_clone(clone);
	AST_class_name::deep_clone(clone);
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_class_name::try_match(Object* pattern)
{
	Token_class_name* that = dynamic_cast<Token_class_name*>(pattern);
	if(!that) return false;
	
	if(!AST_target::try_match(that)) return false;
	if(!AST_class_name::try_match(that)) return false;
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_class_name::replace_wildcards(Object* pattern)
{
	Token_class_name* that = dynamic_cast<Token_class_name*>(pattern);
	assert(that);
	
	AST_target::replace_wildcards(that);
	AST_class_name::replace_wildcards(that);
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_class_name::get_value_as_string()
{
	return value;
}

Token_class_name* Token_class_name::transform(Tree_transform* transform)
{
	Token_class_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_class_name* Token_class_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_class_name(this);
}

void Token_class_name::transform_children(Tree_transform* transform)
{
	transform->children_class_name(this);
}

Token_class_name* Token_class_name::post_transform(Tree_transform* transform)
{
	return transform->post_class_name(this);
}

void Token_class_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_class_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_class_name(this);
	visitor->pre_target(this);
	visitor->pre_class_name(this);
}

void Token_class_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_class_name(this);
}

void Token_class_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_class_name(this);
	visitor->post_target(this);
	visitor->post_class_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_method_name::Token_method_name()
{
}

Token_method_name::Token_method_name(String* value)
{
	this->value = value;
}

bool Token_method_name::deep_equals(Object* other)
{
	Token_method_name* that = dynamic_cast<Token_method_name*>(other);
	if(!that) return false;
	
	if(!AST_method_name::deep_equals(that)) return false;
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_method_name* Token_method_name::deep_clone(Object* partial_result)
{
	Token_method_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_method_name*>(partial_result);
	else
		clone = new Token_method_name();
	assert(clone);
	
	AST_method_name::deep_clone(clone);
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_method_name::try_match(Object* pattern)
{
	Token_method_name* that = dynamic_cast<Token_method_name*>(pattern);
	if(!that) return false;
	
	if(!AST_method_name::try_match(that)) return false;
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_method_name::replace_wildcards(Object* pattern)
{
	Token_method_name* that = dynamic_cast<Token_method_name*>(pattern);
	assert(that);
	
	AST_method_name::replace_wildcards(that);
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_method_name::get_value_as_string()
{
	return value;
}

Token_method_name* Token_method_name::transform(Tree_transform* transform)
{
	Token_method_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_method_name* Token_method_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_method_name(this);
}

void Token_method_name::transform_children(Tree_transform* transform)
{
	transform->children_method_name(this);
}

Token_method_name* Token_method_name::post_transform(Tree_transform* transform)
{
	return transform->post_method_name(this);
}

void Token_method_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_method_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_method_name(this);
	visitor->pre_method_name(this);
}

void Token_method_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_method_name(this);
}

void Token_method_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_method_name(this);
	visitor->post_method_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_variable_name::Token_variable_name()
{
}

Token_variable_name::Token_variable_name(String* value)
{
	this->value = value;
}

bool Token_variable_name::deep_equals(Object* other)
{
	Token_variable_name* that = dynamic_cast<Token_variable_name*>(other);
	if(!that) return false;
	
	if(!AST_variable_name::deep_equals(that)) return false;
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_variable_name* Token_variable_name::deep_clone(Object* partial_result)
{
	Token_variable_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_variable_name*>(partial_result);
	else
		clone = new Token_variable_name();
	assert(clone);
	
	AST_variable_name::deep_clone(clone);
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_variable_name::try_match(Object* pattern)
{
	Token_variable_name* that = dynamic_cast<Token_variable_name*>(pattern);
	if(!that) return false;
	
	if(!AST_variable_name::try_match(that)) return false;
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_variable_name::replace_wildcards(Object* pattern)
{
	Token_variable_name* that = dynamic_cast<Token_variable_name*>(pattern);
	assert(that);
	
	AST_variable_name::replace_wildcards(that);
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_variable_name::get_value_as_string()
{
	return value;
}

Token_variable_name* Token_variable_name::transform(Tree_transform* transform)
{
	Token_variable_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_variable_name* Token_variable_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_variable_name(this);
}

void Token_variable_name::transform_children(Tree_transform* transform)
{
	transform->children_variable_name(this);
}

Token_variable_name* Token_variable_name::post_transform(Tree_transform* transform)
{
	return transform->post_variable_name(this);
}

void Token_variable_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_variable_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_variable_name(this);
	visitor->pre_variable_name(this);
}

void Token_variable_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_variable_name(this);
}

void Token_variable_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_variable_name(this);
	visitor->post_variable_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_directive_name::Token_directive_name()
{
}

Token_directive_name::Token_directive_name(String* value)
{
	this->value = value;
}

bool Token_directive_name::deep_equals(Object* other)
{
	Token_directive_name* that = dynamic_cast<Token_directive_name*>(other);
	if(!that) return false;
	
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_directive_name* Token_directive_name::deep_clone(Object* partial_result)
{
	Token_directive_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_directive_name*>(partial_result);
	else
		clone = new Token_directive_name();
	assert(clone);
	
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_directive_name::try_match(Object* pattern)
{
	Token_directive_name* that = dynamic_cast<Token_directive_name*>(pattern);
	if(!that) return false;
	
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_directive_name::replace_wildcards(Object* pattern)
{
	Token_directive_name* that = dynamic_cast<Token_directive_name*>(pattern);
	assert(that);
	
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_directive_name::get_value_as_string()
{
	return value;
}

Token_directive_name* Token_directive_name::transform(Tree_transform* transform)
{
	Token_directive_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_directive_name* Token_directive_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_directive_name(this);
}

void Token_directive_name::transform_children(Tree_transform* transform)
{
	transform->children_directive_name(this);
}

Token_directive_name* Token_directive_name::post_transform(Tree_transform* transform)
{
	return transform->post_directive_name(this);
}

void Token_directive_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_directive_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_directive_name(this);
}

void Token_directive_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_directive_name(this);
}

void Token_directive_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_directive_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_cast::Token_cast()
{
}

Token_cast::Token_cast(String* value)
{
	this->value = value;
}

bool Token_cast::deep_equals(Object* other)
{
	Token_cast* that = dynamic_cast<Token_cast*>(other);
	if(!that) return false;
	
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_cast* Token_cast::deep_clone(Object* partial_result)
{
	Token_cast* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_cast*>(partial_result);
	else
		clone = new Token_cast();
	assert(clone);
	
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_cast::try_match(Object* pattern)
{
	Token_cast* that = dynamic_cast<Token_cast*>(pattern);
	if(!that) return false;
	
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_cast::replace_wildcards(Object* pattern)
{
	Token_cast* that = dynamic_cast<Token_cast*>(pattern);
	assert(that);
	
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_cast::get_value_as_string()
{
	return value;
}

Token_cast* Token_cast::transform(Tree_transform* transform)
{
	Token_cast* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_cast* Token_cast::pre_transform(Tree_transform* transform)
{
	return transform->pre_cast(this);
}

void Token_cast::transform_children(Tree_transform* transform)
{
	transform->children_cast(this);
}

Token_cast* Token_cast::post_transform(Tree_transform* transform)
{
	return transform->post_cast(this);
}

void Token_cast::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_cast::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_cast(this);
}

void Token_cast::visit_children(Tree_visitor* visitor)
{
	visitor->children_cast(this);
}

void Token_cast::post_visit(Tree_visitor* visitor)
{
	visitor->post_cast(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_op::Token_op()
{
}

Token_op::Token_op(String* value)
{
	this->value = value;
}

bool Token_op::deep_equals(Object* other)
{
	Token_op* that = dynamic_cast<Token_op*>(other);
	if(!that) return false;
	
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_op* Token_op::deep_clone(Object* partial_result)
{
	Token_op* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_op*>(partial_result);
	else
		clone = new Token_op();
	assert(clone);
	
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_op::try_match(Object* pattern)
{
	Token_op* that = dynamic_cast<Token_op*>(pattern);
	if(!that) return false;
	
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_op::replace_wildcards(Object* pattern)
{
	Token_op* that = dynamic_cast<Token_op*>(pattern);
	assert(that);
	
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_op::get_value_as_string()
{
	return value;
}

Token_op* Token_op::transform(Tree_transform* transform)
{
	Token_op* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_op* Token_op::pre_transform(Tree_transform* transform)
{
	return transform->pre_op(this);
}

void Token_op::transform_children(Tree_transform* transform)
{
	transform->children_op(this);
}

Token_op* Token_op::post_transform(Tree_transform* transform)
{
	return transform->post_op(this);
}

void Token_op::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_op::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_op(this);
}

void Token_op::visit_children(Tree_visitor* visitor)
{
	visitor->children_op(this);
}

void Token_op::post_visit(Tree_visitor* visitor)
{
	visitor->post_op(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

Token_constant_name::Token_constant_name()
{
}

Token_constant_name::Token_constant_name(String* value)
{
	this->value = value;
}

bool Token_constant_name::deep_equals(Object* other)
{
	Token_constant_name* that = dynamic_cast<Token_constant_name*>(other);
	if(!that) return false;
	
	if(!AST_identifier::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	
	return true;
}

Token_constant_name* Token_constant_name::deep_clone(Object* partial_result)
{
	Token_constant_name* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_constant_name*>(partial_result);
	else
		clone = new Token_constant_name();
	assert(clone);
	
	AST_identifier::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	return clone;
}

bool Token_constant_name::try_match(Object* pattern)
{
	Token_constant_name* that = dynamic_cast<Token_constant_name*>(pattern);
	if(!that) return false;
	
	if(!AST_identifier::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	
	return true;
}

void Token_constant_name::replace_wildcards(Object* pattern)
{
	Token_constant_name* that = dynamic_cast<Token_constant_name*>(pattern);
	assert(that);
	
	AST_identifier::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
}

String* Token_constant_name::get_value_as_string()
{
	return value;
}

Token_constant_name* Token_constant_name::transform(Tree_transform* transform)
{
	Token_constant_name* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

Token_constant_name* Token_constant_name::pre_transform(Tree_transform* transform)
{
	return transform->pre_constant_name(this);
}

void Token_constant_name::transform_children(Tree_transform* transform)
{
	transform->children_constant_name(this);
}

Token_constant_name* Token_constant_name::post_transform(Tree_transform* transform)
{
	return transform->post_constant_name(this);
}

void Token_constant_name::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_constant_name::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_identifier(this);
	visitor->pre_constant_name(this);
}

void Token_constant_name::visit_children(Tree_visitor* visitor)
{
	visitor->children_constant_name(this);
}

void Token_constant_name::post_visit(Tree_visitor* visitor)
{
	visitor->post_constant_name(this);
	visitor->post_identifier(this);
	visitor->post_node(this);
}

AST_method::AST_method()
{
}

AST_method::AST_method(AST_signature* signature, AST_statement_list* statements)
{
	this->signature = signature;
	this->statements = statements;
}

bool AST_method::deep_equals(Object* other)
{
	AST_method* that = dynamic_cast<AST_method*>(other);
	if(!that) return false;
	
	if(!AST_member::deep_equals(that)) return false;
	
	if(signature == NULL)
		{ if(that->signature != NULL) return false; }
	else
		{ if(!signature->deep_equals(that->signature)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_method* AST_method::deep_clone(Object* partial_result)
{
	AST_method* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_method*>(partial_result);
	else
		clone = new AST_method();
	assert(clone);
	
	AST_member::deep_clone(clone);
	
	if(signature)
		clone->signature = signature->deep_clone();
	else
		clone->signature = NULL;
	assert(!signature || clone->signature);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_method::try_match(Object* pattern)
{
	AST_method* that = dynamic_cast<AST_method*>(pattern);
	if(!that) return false;
	
	if(!AST_member::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->signature) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(signature == NULL)
		{ if(that->signature != NULL) return false; }
	else
		{ if(!signature->try_match(that->signature)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_method::replace_wildcards(Object* pattern)
{
	AST_method* that = dynamic_cast<AST_method*>(pattern);
	assert(that);
	
	AST_member::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->signature) == dynamic_cast<void*>(WILDCARD))
		{ that->signature = signature; }
	else if(signature != NULL)
		{ signature->replace_wildcards(that->signature); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_member_list* AST_method::transform(Tree_transform* transform)
{
	AST_member_list* node = pre_transform(transform);
	AST_member_list::const_iterator i;
	AST_member_list* new_v = new AST_member_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_member_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_member_list* AST_method::pre_transform(Tree_transform* transform)
{
	AST_member_list* new_v = new AST_member_list;
	transform->pre_method(this, new_v);
	return new_v;
}

void AST_method::transform_children(Tree_transform* transform)
{
	transform->children_method(this);
}

AST_member_list* AST_method::post_transform(Tree_transform* transform)
{
	AST_member_list* new_v = new AST_member_list;
	transform->post_method(this, new_v);
	return new_v;
}

void AST_method::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_method::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_member(this);
	visitor->pre_method(this);
}

void AST_method::visit_children(Tree_visitor* visitor)
{
	visitor->children_method(this);
}

void AST_method::post_visit(Tree_visitor* visitor)
{
	visitor->post_method(this);
	visitor->post_member(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_attribute::AST_attribute()
{
}

AST_attribute::AST_attribute(AST_attr_mod* attr_mod, Token_variable_name* variable_name, AST_expr* expr)
{
	this->attr_mod = attr_mod;
	this->variable_name = variable_name;
	this->expr = expr;
}

bool AST_attribute::deep_equals(Object* other)
{
	AST_attribute* that = dynamic_cast<AST_attribute*>(other);
	if(!that) return false;
	
	if(!AST_member::deep_equals(that)) return false;
	
	if(attr_mod == NULL)
		{ if(that->attr_mod != NULL) return false; }
	else
		{ if(!attr_mod->deep_equals(that->attr_mod)) return false; }
	if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->deep_equals(that->variable_name)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_attribute* AST_attribute::deep_clone(Object* partial_result)
{
	AST_attribute* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_attribute*>(partial_result);
	else
		clone = new AST_attribute();
	assert(clone);
	
	AST_member::deep_clone(clone);
	
	if(attr_mod)
		clone->attr_mod = attr_mod->deep_clone();
	else
		clone->attr_mod = NULL;
	assert(!attr_mod || clone->attr_mod);
	
	if(variable_name)
		clone->variable_name = variable_name->deep_clone();
	else
		clone->variable_name = NULL;
	assert(!variable_name || clone->variable_name);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_attribute::try_match(Object* pattern)
{
	AST_attribute* that = dynamic_cast<AST_attribute*>(pattern);
	if(!that) return false;
	
	if(!AST_member::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->attr_mod) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(attr_mod == NULL)
		{ if(that->attr_mod != NULL) return false; }
	else
		{ if(!attr_mod->try_match(that->attr_mod)) return false; }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->try_match(that->variable_name)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_attribute::replace_wildcards(Object* pattern)
{
	AST_attribute* that = dynamic_cast<AST_attribute*>(pattern);
	assert(that);
	
	AST_member::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->attr_mod) == dynamic_cast<void*>(WILDCARD))
		{ that->attr_mod = attr_mod; }
	else if(attr_mod != NULL)
		{ attr_mod->replace_wildcards(that->attr_mod); }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ that->variable_name = variable_name; }
	else if(variable_name != NULL)
		{ variable_name->replace_wildcards(that->variable_name); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_member_list* AST_attribute::transform(Tree_transform* transform)
{
	AST_member_list* node = pre_transform(transform);
	AST_member_list::const_iterator i;
	AST_member_list* new_v = new AST_member_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_member_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_member_list* AST_attribute::pre_transform(Tree_transform* transform)
{
	AST_member_list* new_v = new AST_member_list;
	transform->pre_attribute(this, new_v);
	return new_v;
}

void AST_attribute::transform_children(Tree_transform* transform)
{
	transform->children_attribute(this);
}

AST_member_list* AST_attribute::post_transform(Tree_transform* transform)
{
	AST_member_list* new_v = new AST_member_list;
	transform->post_attribute(this, new_v);
	return new_v;
}

void AST_attribute::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_attribute::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_member(this);
	visitor->pre_attribute(this);
}

void AST_attribute::visit_children(Tree_visitor* visitor)
{
	visitor->children_attribute(this);
}

void AST_attribute::post_visit(Tree_visitor* visitor)
{
	visitor->post_attribute(this);
	visitor->post_member(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_if::AST_if()
{
	init();
}

AST_if::AST_if(AST_expr* expr, AST_statement_list* iftrue, AST_statement_list* iffalse)
{
	init();
	this->expr = expr;
	this->iftrue = iftrue;
	this->iffalse = iffalse;
}

bool AST_if::deep_equals(Object* other)
{
	AST_if* that = dynamic_cast<AST_if*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(iftrue == NULL)
		{ if(that->iftrue != NULL) return false; }
	else
		{ if(!iftrue->deep_equals(that->iftrue)) return false; }
	if(iffalse == NULL)
		{ if(that->iffalse != NULL) return false; }
	else
		{ if(!iffalse->deep_equals(that->iffalse)) return false; }
	
	return true;
}

AST_if* AST_if::deep_clone(Object* partial_result)
{
	AST_if* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_if*>(partial_result);
	else
		clone = new AST_if();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(iftrue)
		clone->iftrue = iftrue->deep_clone();
	else
		clone->iftrue = NULL;
	assert(!iftrue || clone->iftrue);
	
	if(iffalse)
		clone->iffalse = iffalse->deep_clone();
	else
		clone->iffalse = NULL;
	assert(!iffalse || clone->iffalse);
	
	return clone;
}

bool AST_if::try_match(Object* pattern)
{
	AST_if* that = dynamic_cast<AST_if*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->iftrue) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(iftrue == NULL)
		{ if(that->iftrue != NULL) return false; }
	else
		{ if(!iftrue->try_match(that->iftrue)) return false; }
	if(dynamic_cast<void*>(that->iffalse) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(iffalse == NULL)
		{ if(that->iffalse != NULL) return false; }
	else
		{ if(!iffalse->try_match(that->iffalse)) return false; }
	
	return true;
}

void AST_if::replace_wildcards(Object* pattern)
{
	AST_if* that = dynamic_cast<AST_if*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->iftrue) == dynamic_cast<void*>(WILDCARD))
		{ that->iftrue = iftrue; }
	else if(iftrue != NULL)
		{ iftrue->replace_wildcards(that->iftrue); }
	if(dynamic_cast<void*>(that->iffalse) == dynamic_cast<void*>(WILDCARD))
		{ that->iffalse = iffalse; }
	else if(iffalse != NULL)
		{ iffalse->replace_wildcards(that->iffalse); }
}

AST_statement_list* AST_if::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_if::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_if(this, new_v);
	return new_v;
}

void AST_if::transform_children(Tree_transform* transform)
{
	transform->children_if(this);
}

AST_statement_list* AST_if::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_if(this, new_v);
	return new_v;
}

void AST_if::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_if::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_if(this);
}

void AST_if::visit_children(Tree_visitor* visitor)
{
	visitor->children_if(this);
}

void AST_if::post_visit(Tree_visitor* visitor)
{
	visitor->post_if(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

void AST_if::init()
{
	attrs->set("phc.unparser.is_elseif", new Boolean(false));
}

AST_while::AST_while()
{
}

AST_while::AST_while(AST_expr* expr, AST_statement_list* statements)
{
	this->expr = expr;
	this->statements = statements;
}

bool AST_while::deep_equals(Object* other)
{
	AST_while* that = dynamic_cast<AST_while*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_while* AST_while::deep_clone(Object* partial_result)
{
	AST_while* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_while*>(partial_result);
	else
		clone = new AST_while();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_while::try_match(Object* pattern)
{
	AST_while* that = dynamic_cast<AST_while*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_while::replace_wildcards(Object* pattern)
{
	AST_while* that = dynamic_cast<AST_while*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_statement_list* AST_while::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_while::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_while(this, new_v);
	return new_v;
}

void AST_while::transform_children(Tree_transform* transform)
{
	transform->children_while(this);
}

AST_statement_list* AST_while::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_while(this, new_v);
	return new_v;
}

void AST_while::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_while::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_while(this);
}

void AST_while::visit_children(Tree_visitor* visitor)
{
	visitor->children_while(this);
}

void AST_while::post_visit(Tree_visitor* visitor)
{
	visitor->post_while(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_do::AST_do()
{
}

AST_do::AST_do(AST_statement_list* statements, AST_expr* expr)
{
	this->statements = statements;
	this->expr = expr;
}

bool AST_do::deep_equals(Object* other)
{
	AST_do* that = dynamic_cast<AST_do*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_do* AST_do::deep_clone(Object* partial_result)
{
	AST_do* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_do*>(partial_result);
	else
		clone = new AST_do();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_do::try_match(Object* pattern)
{
	AST_do* that = dynamic_cast<AST_do*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_do::replace_wildcards(Object* pattern)
{
	AST_do* that = dynamic_cast<AST_do*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_do::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_do::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_do(this, new_v);
	return new_v;
}

void AST_do::transform_children(Tree_transform* transform)
{
	transform->children_do(this);
}

AST_statement_list* AST_do::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_do(this, new_v);
	return new_v;
}

void AST_do::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_do::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_do(this);
}

void AST_do::visit_children(Tree_visitor* visitor)
{
	visitor->children_do(this);
}

void AST_do::post_visit(Tree_visitor* visitor)
{
	visitor->post_do(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_for::AST_for()
{
}

AST_for::AST_for(AST_expr* init, AST_expr* cond, AST_expr* incr, AST_statement_list* statements)
{
	this->init = init;
	this->cond = cond;
	this->incr = incr;
	this->statements = statements;
}

bool AST_for::deep_equals(Object* other)
{
	AST_for* that = dynamic_cast<AST_for*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(init == NULL)
		{ if(that->init != NULL) return false; }
	else
		{ if(!init->deep_equals(that->init)) return false; }
	if(cond == NULL)
		{ if(that->cond != NULL) return false; }
	else
		{ if(!cond->deep_equals(that->cond)) return false; }
	if(incr == NULL)
		{ if(that->incr != NULL) return false; }
	else
		{ if(!incr->deep_equals(that->incr)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_for* AST_for::deep_clone(Object* partial_result)
{
	AST_for* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_for*>(partial_result);
	else
		clone = new AST_for();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(init)
		clone->init = init->deep_clone();
	else
		clone->init = NULL;
	assert(!init || clone->init);
	
	if(cond)
		clone->cond = cond->deep_clone();
	else
		clone->cond = NULL;
	assert(!cond || clone->cond);
	
	if(incr)
		clone->incr = incr->deep_clone();
	else
		clone->incr = NULL;
	assert(!incr || clone->incr);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_for::try_match(Object* pattern)
{
	AST_for* that = dynamic_cast<AST_for*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->init) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(init == NULL)
		{ if(that->init != NULL) return false; }
	else
		{ if(!init->try_match(that->init)) return false; }
	if(dynamic_cast<void*>(that->cond) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(cond == NULL)
		{ if(that->cond != NULL) return false; }
	else
		{ if(!cond->try_match(that->cond)) return false; }
	if(dynamic_cast<void*>(that->incr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(incr == NULL)
		{ if(that->incr != NULL) return false; }
	else
		{ if(!incr->try_match(that->incr)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_for::replace_wildcards(Object* pattern)
{
	AST_for* that = dynamic_cast<AST_for*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->init) == dynamic_cast<void*>(WILDCARD))
		{ that->init = init; }
	else if(init != NULL)
		{ init->replace_wildcards(that->init); }
	if(dynamic_cast<void*>(that->cond) == dynamic_cast<void*>(WILDCARD))
		{ that->cond = cond; }
	else if(cond != NULL)
		{ cond->replace_wildcards(that->cond); }
	if(dynamic_cast<void*>(that->incr) == dynamic_cast<void*>(WILDCARD))
		{ that->incr = incr; }
	else if(incr != NULL)
		{ incr->replace_wildcards(that->incr); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_statement_list* AST_for::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_for::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_for(this, new_v);
	return new_v;
}

void AST_for::transform_children(Tree_transform* transform)
{
	transform->children_for(this);
}

AST_statement_list* AST_for::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_for(this, new_v);
	return new_v;
}

void AST_for::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_for::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_for(this);
}

void AST_for::visit_children(Tree_visitor* visitor)
{
	visitor->children_for(this);
}

void AST_for::post_visit(Tree_visitor* visitor)
{
	visitor->post_for(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_foreach::AST_foreach()
{
}

AST_foreach::AST_foreach(AST_expr* expr, AST_variable* key, bool is_ref, AST_variable* val, AST_statement_list* statements)
{
	this->expr = expr;
	this->key = key;
	this->is_ref = is_ref;
	this->val = val;
	this->statements = statements;
}

bool AST_foreach::deep_equals(Object* other)
{
	AST_foreach* that = dynamic_cast<AST_foreach*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(key == NULL)
		{ if(that->key != NULL) return false; }
	else
		{ if(!key->deep_equals(that->key)) return false; }
	if(is_ref != that->is_ref) return false;
	if(val == NULL)
		{ if(that->val != NULL) return false; }
	else
		{ if(!val->deep_equals(that->val)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_foreach* AST_foreach::deep_clone(Object* partial_result)
{
	AST_foreach* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_foreach*>(partial_result);
	else
		clone = new AST_foreach();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(key)
		clone->key = key->deep_clone();
	else
		clone->key = NULL;
	assert(!key || clone->key);
	
	clone->is_ref = is_ref;
	
	if(val)
		clone->val = val->deep_clone();
	else
		clone->val = NULL;
	assert(!val || clone->val);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_foreach::try_match(Object* pattern)
{
	AST_foreach* that = dynamic_cast<AST_foreach*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->key) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(key == NULL)
		{ if(that->key != NULL) return false; }
	else
		{ if(!key->try_match(that->key)) return false; }
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->val) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(val == NULL)
		{ if(that->val != NULL) return false; }
	else
		{ if(!val->try_match(that->val)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_foreach::replace_wildcards(Object* pattern)
{
	AST_foreach* that = dynamic_cast<AST_foreach*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->key) == dynamic_cast<void*>(WILDCARD))
		{ that->key = key; }
	else if(key != NULL)
		{ key->replace_wildcards(that->key); }
	if(dynamic_cast<void*>(that->val) == dynamic_cast<void*>(WILDCARD))
		{ that->val = val; }
	else if(val != NULL)
		{ val->replace_wildcards(that->val); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_statement_list* AST_foreach::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_foreach::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_foreach(this, new_v);
	return new_v;
}

void AST_foreach::transform_children(Tree_transform* transform)
{
	transform->children_foreach(this);
}

AST_statement_list* AST_foreach::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_foreach(this, new_v);
	return new_v;
}

void AST_foreach::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_foreach::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_foreach(this);
}

void AST_foreach::visit_children(Tree_visitor* visitor)
{
	visitor->children_foreach(this);
}

void AST_foreach::post_visit(Tree_visitor* visitor)
{
	visitor->post_foreach(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_switch::AST_switch()
{
}

AST_switch::AST_switch(AST_expr* expr, AST_switch_case_list* switch_cases)
{
	this->expr = expr;
	this->switch_cases = switch_cases;
}

bool AST_switch::deep_equals(Object* other)
{
	AST_switch* that = dynamic_cast<AST_switch*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(switch_cases == NULL)
		{ if(that->switch_cases != NULL) return false; }
	else
		{ if(!switch_cases->deep_equals(that->switch_cases)) return false; }
	
	return true;
}

AST_switch* AST_switch::deep_clone(Object* partial_result)
{
	AST_switch* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_switch*>(partial_result);
	else
		clone = new AST_switch();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(switch_cases)
		clone->switch_cases = switch_cases->deep_clone();
	else
		clone->switch_cases = NULL;
	assert(!switch_cases || clone->switch_cases);
	
	return clone;
}

bool AST_switch::try_match(Object* pattern)
{
	AST_switch* that = dynamic_cast<AST_switch*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->switch_cases) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(switch_cases == NULL)
		{ if(that->switch_cases != NULL) return false; }
	else
		{ if(!switch_cases->try_match(that->switch_cases)) return false; }
	
	return true;
}

void AST_switch::replace_wildcards(Object* pattern)
{
	AST_switch* that = dynamic_cast<AST_switch*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->switch_cases) == dynamic_cast<void*>(WILDCARD))
		{ that->switch_cases = switch_cases; }
	else if(switch_cases != NULL)
		{ switch_cases->replace_wildcards(that->switch_cases); }
}

AST_statement_list* AST_switch::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_switch::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_switch(this, new_v);
	return new_v;
}

void AST_switch::transform_children(Tree_transform* transform)
{
	transform->children_switch(this);
}

AST_statement_list* AST_switch::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_switch(this, new_v);
	return new_v;
}

void AST_switch::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_switch::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_switch(this);
}

void AST_switch::visit_children(Tree_visitor* visitor)
{
	visitor->children_switch(this);
}

void AST_switch::post_visit(Tree_visitor* visitor)
{
	visitor->post_switch(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_break::AST_break()
{
}

AST_break::AST_break(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_break::deep_equals(Object* other)
{
	AST_break* that = dynamic_cast<AST_break*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_break* AST_break::deep_clone(Object* partial_result)
{
	AST_break* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_break*>(partial_result);
	else
		clone = new AST_break();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_break::try_match(Object* pattern)
{
	AST_break* that = dynamic_cast<AST_break*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_break::replace_wildcards(Object* pattern)
{
	AST_break* that = dynamic_cast<AST_break*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_break::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_break::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_break(this, new_v);
	return new_v;
}

void AST_break::transform_children(Tree_transform* transform)
{
	transform->children_break(this);
}

AST_statement_list* AST_break::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_break(this, new_v);
	return new_v;
}

void AST_break::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_break::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_break(this);
}

void AST_break::visit_children(Tree_visitor* visitor)
{
	visitor->children_break(this);
}

void AST_break::post_visit(Tree_visitor* visitor)
{
	visitor->post_break(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_continue::AST_continue()
{
}

AST_continue::AST_continue(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_continue::deep_equals(Object* other)
{
	AST_continue* that = dynamic_cast<AST_continue*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_continue* AST_continue::deep_clone(Object* partial_result)
{
	AST_continue* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_continue*>(partial_result);
	else
		clone = new AST_continue();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_continue::try_match(Object* pattern)
{
	AST_continue* that = dynamic_cast<AST_continue*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_continue::replace_wildcards(Object* pattern)
{
	AST_continue* that = dynamic_cast<AST_continue*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_continue::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_continue::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_continue(this, new_v);
	return new_v;
}

void AST_continue::transform_children(Tree_transform* transform)
{
	transform->children_continue(this);
}

AST_statement_list* AST_continue::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_continue(this, new_v);
	return new_v;
}

void AST_continue::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_continue::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_continue(this);
}

void AST_continue::visit_children(Tree_visitor* visitor)
{
	visitor->children_continue(this);
}

void AST_continue::post_visit(Tree_visitor* visitor)
{
	visitor->post_continue(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_return::AST_return()
{
}

AST_return::AST_return(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_return::deep_equals(Object* other)
{
	AST_return* that = dynamic_cast<AST_return*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_return* AST_return::deep_clone(Object* partial_result)
{
	AST_return* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_return*>(partial_result);
	else
		clone = new AST_return();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_return::try_match(Object* pattern)
{
	AST_return* that = dynamic_cast<AST_return*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_return::replace_wildcards(Object* pattern)
{
	AST_return* that = dynamic_cast<AST_return*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_return::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_return::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_return(this, new_v);
	return new_v;
}

void AST_return::transform_children(Tree_transform* transform)
{
	transform->children_return(this);
}

AST_statement_list* AST_return::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_return(this, new_v);
	return new_v;
}

void AST_return::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_return::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_return(this);
}

void AST_return::visit_children(Tree_visitor* visitor)
{
	visitor->children_return(this);
}

void AST_return::post_visit(Tree_visitor* visitor)
{
	visitor->post_return(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_static_declaration::AST_static_declaration()
{
}

AST_static_declaration::AST_static_declaration(Token_variable_name* variable_name, AST_expr* expr)
{
	this->variable_name = variable_name;
	this->expr = expr;
}

bool AST_static_declaration::deep_equals(Object* other)
{
	AST_static_declaration* that = dynamic_cast<AST_static_declaration*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->deep_equals(that->variable_name)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_static_declaration* AST_static_declaration::deep_clone(Object* partial_result)
{
	AST_static_declaration* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_static_declaration*>(partial_result);
	else
		clone = new AST_static_declaration();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(variable_name)
		clone->variable_name = variable_name->deep_clone();
	else
		clone->variable_name = NULL;
	assert(!variable_name || clone->variable_name);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_static_declaration::try_match(Object* pattern)
{
	AST_static_declaration* that = dynamic_cast<AST_static_declaration*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->try_match(that->variable_name)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_static_declaration::replace_wildcards(Object* pattern)
{
	AST_static_declaration* that = dynamic_cast<AST_static_declaration*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ that->variable_name = variable_name; }
	else if(variable_name != NULL)
		{ variable_name->replace_wildcards(that->variable_name); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_static_declaration::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_static_declaration::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_static_declaration(this, new_v);
	return new_v;
}

void AST_static_declaration::transform_children(Tree_transform* transform)
{
	transform->children_static_declaration(this);
}

AST_statement_list* AST_static_declaration::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_static_declaration(this, new_v);
	return new_v;
}

void AST_static_declaration::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_static_declaration::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_static_declaration(this);
}

void AST_static_declaration::visit_children(Tree_visitor* visitor)
{
	visitor->children_static_declaration(this);
}

void AST_static_declaration::post_visit(Tree_visitor* visitor)
{
	visitor->post_static_declaration(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_unset::AST_unset()
{
}

AST_unset::AST_unset(AST_variable* variable)
{
	this->variable = variable;
}

bool AST_unset::deep_equals(Object* other)
{
	AST_unset* that = dynamic_cast<AST_unset*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->deep_equals(that->variable)) return false; }
	
	return true;
}

AST_unset* AST_unset::deep_clone(Object* partial_result)
{
	AST_unset* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_unset*>(partial_result);
	else
		clone = new AST_unset();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(variable)
		clone->variable = variable->deep_clone();
	else
		clone->variable = NULL;
	assert(!variable || clone->variable);
	
	return clone;
}

bool AST_unset::try_match(Object* pattern)
{
	AST_unset* that = dynamic_cast<AST_unset*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->try_match(that->variable)) return false; }
	
	return true;
}

void AST_unset::replace_wildcards(Object* pattern)
{
	AST_unset* that = dynamic_cast<AST_unset*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ that->variable = variable; }
	else if(variable != NULL)
		{ variable->replace_wildcards(that->variable); }
}

AST_statement_list* AST_unset::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_unset::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_unset(this, new_v);
	return new_v;
}

void AST_unset::transform_children(Tree_transform* transform)
{
	transform->children_unset(this);
}

AST_statement_list* AST_unset::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_unset(this, new_v);
	return new_v;
}

void AST_unset::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_unset::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_unset(this);
}

void AST_unset::visit_children(Tree_visitor* visitor)
{
	visitor->children_unset(this);
}

void AST_unset::post_visit(Tree_visitor* visitor)
{
	visitor->post_unset(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_declare::AST_declare()
{
}

AST_declare::AST_declare(AST_directive_list* directives, AST_statement_list* statements)
{
	this->directives = directives;
	this->statements = statements;
}

bool AST_declare::deep_equals(Object* other)
{
	AST_declare* that = dynamic_cast<AST_declare*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(directives == NULL)
		{ if(that->directives != NULL) return false; }
	else
		{ if(!directives->deep_equals(that->directives)) return false; }
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	
	return true;
}

AST_declare* AST_declare::deep_clone(Object* partial_result)
{
	AST_declare* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_declare*>(partial_result);
	else
		clone = new AST_declare();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(directives)
		clone->directives = directives->deep_clone();
	else
		clone->directives = NULL;
	assert(!directives || clone->directives);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	return clone;
}

bool AST_declare::try_match(Object* pattern)
{
	AST_declare* that = dynamic_cast<AST_declare*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->directives) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(directives == NULL)
		{ if(that->directives != NULL) return false; }
	else
		{ if(!directives->try_match(that->directives)) return false; }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	
	return true;
}

void AST_declare::replace_wildcards(Object* pattern)
{
	AST_declare* that = dynamic_cast<AST_declare*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->directives) == dynamic_cast<void*>(WILDCARD))
		{ that->directives = directives; }
	else if(directives != NULL)
		{ directives->replace_wildcards(that->directives); }
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
}

AST_statement_list* AST_declare::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_declare::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_declare(this, new_v);
	return new_v;
}

void AST_declare::transform_children(Tree_transform* transform)
{
	transform->children_declare(this);
}

AST_statement_list* AST_declare::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_declare(this, new_v);
	return new_v;
}

void AST_declare::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_declare::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_declare(this);
}

void AST_declare::visit_children(Tree_visitor* visitor)
{
	visitor->children_declare(this);
}

void AST_declare::post_visit(Tree_visitor* visitor)
{
	visitor->post_declare(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_try::AST_try()
{
}

AST_try::AST_try(AST_statement_list* statements, AST_catch_list* catches)
{
	this->statements = statements;
	this->catches = catches;
}

bool AST_try::deep_equals(Object* other)
{
	AST_try* that = dynamic_cast<AST_try*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->deep_equals(that->statements)) return false; }
	if(catches == NULL)
		{ if(that->catches != NULL) return false; }
	else
		{ if(!catches->deep_equals(that->catches)) return false; }
	
	return true;
}

AST_try* AST_try::deep_clone(Object* partial_result)
{
	AST_try* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_try*>(partial_result);
	else
		clone = new AST_try();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(statements)
		clone->statements = statements->deep_clone();
	else
		clone->statements = NULL;
	assert(!statements || clone->statements);
	
	if(catches)
		clone->catches = catches->deep_clone();
	else
		clone->catches = NULL;
	assert(!catches || clone->catches);
	
	return clone;
}

bool AST_try::try_match(Object* pattern)
{
	AST_try* that = dynamic_cast<AST_try*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(statements == NULL)
		{ if(that->statements != NULL) return false; }
	else
		{ if(!statements->try_match(that->statements)) return false; }
	if(dynamic_cast<void*>(that->catches) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(catches == NULL)
		{ if(that->catches != NULL) return false; }
	else
		{ if(!catches->try_match(that->catches)) return false; }
	
	return true;
}

void AST_try::replace_wildcards(Object* pattern)
{
	AST_try* that = dynamic_cast<AST_try*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->statements) == dynamic_cast<void*>(WILDCARD))
		{ that->statements = statements; }
	else if(statements != NULL)
		{ statements->replace_wildcards(that->statements); }
	if(dynamic_cast<void*>(that->catches) == dynamic_cast<void*>(WILDCARD))
		{ that->catches = catches; }
	else if(catches != NULL)
		{ catches->replace_wildcards(that->catches); }
}

AST_statement_list* AST_try::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_try::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_try(this, new_v);
	return new_v;
}

void AST_try::transform_children(Tree_transform* transform)
{
	transform->children_try(this);
}

AST_statement_list* AST_try::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_try(this, new_v);
	return new_v;
}

void AST_try::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_try::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_try(this);
}

void AST_try::visit_children(Tree_visitor* visitor)
{
	visitor->children_try(this);
}

void AST_try::post_visit(Tree_visitor* visitor)
{
	visitor->post_try(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_throw::AST_throw()
{
}

AST_throw::AST_throw(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_throw::deep_equals(Object* other)
{
	AST_throw* that = dynamic_cast<AST_throw*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_throw* AST_throw::deep_clone(Object* partial_result)
{
	AST_throw* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_throw*>(partial_result);
	else
		clone = new AST_throw();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_throw::try_match(Object* pattern)
{
	AST_throw* that = dynamic_cast<AST_throw*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_throw::replace_wildcards(Object* pattern)
{
	AST_throw* that = dynamic_cast<AST_throw*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_throw::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_throw::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_throw(this, new_v);
	return new_v;
}

void AST_throw::transform_children(Tree_transform* transform)
{
	transform->children_throw(this);
}

AST_statement_list* AST_throw::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_throw(this, new_v);
	return new_v;
}

void AST_throw::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_throw::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_throw(this);
}

void AST_throw::visit_children(Tree_visitor* visitor)
{
	visitor->children_throw(this);
}

void AST_throw::post_visit(Tree_visitor* visitor)
{
	visitor->post_throw(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_eval_expr::AST_eval_expr()
{
}

AST_eval_expr::AST_eval_expr(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_eval_expr::deep_equals(Object* other)
{
	AST_eval_expr* that = dynamic_cast<AST_eval_expr*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_eval_expr* AST_eval_expr::deep_clone(Object* partial_result)
{
	AST_eval_expr* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_eval_expr*>(partial_result);
	else
		clone = new AST_eval_expr();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_eval_expr::try_match(Object* pattern)
{
	AST_eval_expr* that = dynamic_cast<AST_eval_expr*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_eval_expr::replace_wildcards(Object* pattern)
{
	AST_eval_expr* that = dynamic_cast<AST_eval_expr*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_statement_list* AST_eval_expr::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_eval_expr::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_eval_expr(this, new_v);
	return new_v;
}

void AST_eval_expr::transform_children(Tree_transform* transform)
{
	transform->children_eval_expr(this);
}

AST_statement_list* AST_eval_expr::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_eval_expr(this, new_v);
	return new_v;
}

void AST_eval_expr::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_eval_expr::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_eval_expr(this);
}

void AST_eval_expr::visit_children(Tree_visitor* visitor)
{
	visitor->children_eval_expr(this);
}

void AST_eval_expr::post_visit(Tree_visitor* visitor)
{
	visitor->post_eval_expr(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

AST_nop::AST_nop()
{
}

bool AST_nop::deep_equals(Object* other)
{
	AST_nop* that = dynamic_cast<AST_nop*>(other);
	if(!that) return false;
	
	if(!AST_statement::deep_equals(that)) return false;
	
	
	return true;
}

AST_nop* AST_nop::deep_clone(Object* partial_result)
{
	AST_nop* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_nop*>(partial_result);
	else
		clone = new AST_nop();
	assert(clone);
	
	AST_statement::deep_clone(clone);
	
	return clone;
}

bool AST_nop::try_match(Object* pattern)
{
	AST_nop* that = dynamic_cast<AST_nop*>(pattern);
	if(!that) return false;
	
	if(!AST_statement::try_match(that)) return false;
	
	
	return true;
}

void AST_nop::replace_wildcards(Object* pattern)
{
	AST_nop* that = dynamic_cast<AST_nop*>(pattern);
	assert(that);
	
	AST_statement::replace_wildcards(that);
	
}

AST_statement_list* AST_nop::transform(Tree_transform* transform)
{
	AST_statement_list* node = pre_transform(transform);
	AST_statement_list::const_iterator i;
	AST_statement_list* new_v = new AST_statement_list;
	for(i = node->begin(); i != node->end(); i++)
	{
		if(*i)
		{
			(*i)->transform_children(transform);
			AST_statement_list* ret_v = (*i)->post_transform(transform);
			new_v->push_back_all(ret_v);
		}
		else
		{
			new_v->push_back(NULL);
		}
	}
	return new_v;
}

AST_statement_list* AST_nop::pre_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->pre_nop(this, new_v);
	return new_v;
}

void AST_nop::transform_children(Tree_transform* transform)
{
	transform->children_nop(this);
}

AST_statement_list* AST_nop::post_transform(Tree_transform* transform)
{
	AST_statement_list* new_v = new AST_statement_list;
	transform->post_nop(this, new_v);
	return new_v;
}

void AST_nop::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_nop::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_commented_node(this);
	visitor->pre_statement(this);
	visitor->pre_nop(this);
}

void AST_nop::visit_children(Tree_visitor* visitor)
{
	visitor->children_nop(this);
}

void AST_nop::post_visit(Tree_visitor* visitor)
{
	visitor->post_nop(this);
	visitor->post_statement(this);
	visitor->post_commented_node(this);
	visitor->post_node(this);
}

bool AST_literal::deep_equals(Object* other)
{
	AST_literal* that = dynamic_cast<AST_literal*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	
	return true;
}

AST_literal* AST_literal::deep_clone(Object* partial_result)
{
	// abstract class
	AST_literal* clone = dynamic_cast<AST_literal*>(partial_result);
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	return clone;
}

bool AST_literal::try_match(Object* pattern)
{
	AST_literal* that = dynamic_cast<AST_literal*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	
	return true;
}

void AST_literal::replace_wildcards(Object* pattern)
{
	AST_literal* that = dynamic_cast<AST_literal*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
}











AST_assignment::AST_assignment()
{
	init();
}

AST_assignment::AST_assignment(AST_variable* variable, bool is_ref, AST_expr* expr)
{
	init();
	this->variable = variable;
	this->is_ref = is_ref;
	this->expr = expr;
}

bool AST_assignment::deep_equals(Object* other)
{
	AST_assignment* that = dynamic_cast<AST_assignment*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->deep_equals(that->variable)) return false; }
	if(is_ref != that->is_ref) return false;
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_assignment* AST_assignment::deep_clone(Object* partial_result)
{
	AST_assignment* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_assignment*>(partial_result);
	else
		clone = new AST_assignment();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(variable)
		clone->variable = variable->deep_clone();
	else
		clone->variable = NULL;
	assert(!variable || clone->variable);
	
	clone->is_ref = is_ref;
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_assignment::try_match(Object* pattern)
{
	AST_assignment* that = dynamic_cast<AST_assignment*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->try_match(that->variable)) return false; }
	if(is_ref != that->is_ref) return false;
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_assignment::replace_wildcards(Object* pattern)
{
	AST_assignment* that = dynamic_cast<AST_assignment*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ that->variable = variable; }
	else if(variable != NULL)
		{ variable->replace_wildcards(that->variable); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_assignment::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_assignment::pre_transform(Tree_transform* transform)
{
	return transform->pre_assignment(this);
}

void AST_assignment::transform_children(Tree_transform* transform)
{
	transform->children_assignment(this);
}

AST_expr* AST_assignment::post_transform(Tree_transform* transform)
{
	return transform->post_assignment(this);
}

void AST_assignment::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_assignment::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_assignment(this);
}

void AST_assignment::visit_children(Tree_visitor* visitor)
{
	visitor->children_assignment(this);
}

void AST_assignment::post_visit(Tree_visitor* visitor)
{
	visitor->post_assignment(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

void AST_assignment::init()
{
	attrs->set("phc.unparser.is_global_stmt", new Boolean(false));
}

AST_list_assignment::AST_list_assignment()
{
}

AST_list_assignment::AST_list_assignment(AST_list_elements* list_elements, AST_expr* expr)
{
	this->list_elements = list_elements;
	this->expr = expr;
}

bool AST_list_assignment::deep_equals(Object* other)
{
	AST_list_assignment* that = dynamic_cast<AST_list_assignment*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(list_elements == NULL)
		{ if(that->list_elements != NULL) return false; }
	else
		{ if(!list_elements->deep_equals(that->list_elements)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_list_assignment* AST_list_assignment::deep_clone(Object* partial_result)
{
	AST_list_assignment* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_list_assignment*>(partial_result);
	else
		clone = new AST_list_assignment();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(list_elements)
		clone->list_elements = list_elements->deep_clone();
	else
		clone->list_elements = NULL;
	assert(!list_elements || clone->list_elements);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_list_assignment::try_match(Object* pattern)
{
	AST_list_assignment* that = dynamic_cast<AST_list_assignment*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->list_elements) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(list_elements == NULL)
		{ if(that->list_elements != NULL) return false; }
	else
		{ if(!list_elements->try_match(that->list_elements)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_list_assignment::replace_wildcards(Object* pattern)
{
	AST_list_assignment* that = dynamic_cast<AST_list_assignment*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->list_elements) == dynamic_cast<void*>(WILDCARD))
		{ that->list_elements = list_elements; }
	else if(list_elements != NULL)
		{ list_elements->replace_wildcards(that->list_elements); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_list_assignment::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_list_assignment::pre_transform(Tree_transform* transform)
{
	return transform->pre_list_assignment(this);
}

void AST_list_assignment::transform_children(Tree_transform* transform)
{
	transform->children_list_assignment(this);
}

AST_expr* AST_list_assignment::post_transform(Tree_transform* transform)
{
	return transform->post_list_assignment(this);
}

void AST_list_assignment::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_list_assignment::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_list_assignment(this);
}

void AST_list_assignment::visit_children(Tree_visitor* visitor)
{
	visitor->children_list_assignment(this);
}

void AST_list_assignment::post_visit(Tree_visitor* visitor)
{
	visitor->post_list_assignment(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_cast::AST_cast()
{
}

AST_cast::AST_cast(Token_cast* cast, AST_expr* expr)
{
	this->cast = cast;
	this->expr = expr;
}

AST_cast::AST_cast(char* cast, AST_expr* expr)
{
	this->cast = new Token_cast(new String(cast));
	this->expr = expr;
}

bool AST_cast::deep_equals(Object* other)
{
	AST_cast* that = dynamic_cast<AST_cast*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(cast == NULL)
		{ if(that->cast != NULL) return false; }
	else
		{ if(!cast->deep_equals(that->cast)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_cast* AST_cast::deep_clone(Object* partial_result)
{
	AST_cast* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_cast*>(partial_result);
	else
		clone = new AST_cast();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(cast)
		clone->cast = cast->deep_clone();
	else
		clone->cast = NULL;
	assert(!cast || clone->cast);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_cast::try_match(Object* pattern)
{
	AST_cast* that = dynamic_cast<AST_cast*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->cast) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(cast == NULL)
		{ if(that->cast != NULL) return false; }
	else
		{ if(!cast->try_match(that->cast)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_cast::replace_wildcards(Object* pattern)
{
	AST_cast* that = dynamic_cast<AST_cast*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->cast) == dynamic_cast<void*>(WILDCARD))
		{ that->cast = cast; }
	else if(cast != NULL)
		{ cast->replace_wildcards(that->cast); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_cast::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_cast::pre_transform(Tree_transform* transform)
{
	return transform->pre_cast(this);
}

void AST_cast::transform_children(Tree_transform* transform)
{
	transform->children_cast(this);
}

AST_expr* AST_cast::post_transform(Tree_transform* transform)
{
	return transform->post_cast(this);
}

void AST_cast::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_cast::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_cast(this);
}

void AST_cast::visit_children(Tree_visitor* visitor)
{
	visitor->children_cast(this);
}

void AST_cast::post_visit(Tree_visitor* visitor)
{
	visitor->post_cast(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_unary_op::AST_unary_op()
{
}

AST_unary_op::AST_unary_op(Token_op* op, AST_expr* expr)
{
	this->op = op;
	this->expr = expr;
}

AST_unary_op::AST_unary_op(AST_expr* expr, char* op)
{
	this->expr = expr;
	this->op = new Token_op(new String(op));
}

bool AST_unary_op::deep_equals(Object* other)
{
	AST_unary_op* that = dynamic_cast<AST_unary_op*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->deep_equals(that->op)) return false; }
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_unary_op* AST_unary_op::deep_clone(Object* partial_result)
{
	AST_unary_op* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_unary_op*>(partial_result);
	else
		clone = new AST_unary_op();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(op)
		clone->op = op->deep_clone();
	else
		clone->op = NULL;
	assert(!op || clone->op);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_unary_op::try_match(Object* pattern)
{
	AST_unary_op* that = dynamic_cast<AST_unary_op*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->try_match(that->op)) return false; }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_unary_op::replace_wildcards(Object* pattern)
{
	AST_unary_op* that = dynamic_cast<AST_unary_op*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ that->op = op; }
	else if(op != NULL)
		{ op->replace_wildcards(that->op); }
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_unary_op::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_unary_op::pre_transform(Tree_transform* transform)
{
	return transform->pre_unary_op(this);
}

void AST_unary_op::transform_children(Tree_transform* transform)
{
	transform->children_unary_op(this);
}

AST_expr* AST_unary_op::post_transform(Tree_transform* transform)
{
	return transform->post_unary_op(this);
}

void AST_unary_op::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_unary_op::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_unary_op(this);
}

void AST_unary_op::visit_children(Tree_visitor* visitor)
{
	visitor->children_unary_op(this);
}

void AST_unary_op::post_visit(Tree_visitor* visitor)
{
	visitor->post_unary_op(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_bin_op::AST_bin_op()
{
}

AST_bin_op::AST_bin_op(AST_expr* left, Token_op* op, AST_expr* right)
{
	this->left = left;
	this->op = op;
	this->right = right;
}

AST_bin_op::AST_bin_op(AST_expr* left, AST_expr* right, char* op)
{
	this->left = left;
	this->op = new Token_op(new String(op));
	this->right = right;
}

bool AST_bin_op::deep_equals(Object* other)
{
	AST_bin_op* that = dynamic_cast<AST_bin_op*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(left == NULL)
		{ if(that->left != NULL) return false; }
	else
		{ if(!left->deep_equals(that->left)) return false; }
	if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->deep_equals(that->op)) return false; }
	if(right == NULL)
		{ if(that->right != NULL) return false; }
	else
		{ if(!right->deep_equals(that->right)) return false; }
	
	return true;
}

AST_bin_op* AST_bin_op::deep_clone(Object* partial_result)
{
	AST_bin_op* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_bin_op*>(partial_result);
	else
		clone = new AST_bin_op();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(left)
		clone->left = left->deep_clone();
	else
		clone->left = NULL;
	assert(!left || clone->left);
	
	if(op)
		clone->op = op->deep_clone();
	else
		clone->op = NULL;
	assert(!op || clone->op);
	
	if(right)
		clone->right = right->deep_clone();
	else
		clone->right = NULL;
	assert(!right || clone->right);
	
	return clone;
}

bool AST_bin_op::try_match(Object* pattern)
{
	AST_bin_op* that = dynamic_cast<AST_bin_op*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->left) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(left == NULL)
		{ if(that->left != NULL) return false; }
	else
		{ if(!left->try_match(that->left)) return false; }
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->try_match(that->op)) return false; }
	if(dynamic_cast<void*>(that->right) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(right == NULL)
		{ if(that->right != NULL) return false; }
	else
		{ if(!right->try_match(that->right)) return false; }
	
	return true;
}

void AST_bin_op::replace_wildcards(Object* pattern)
{
	AST_bin_op* that = dynamic_cast<AST_bin_op*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->left) == dynamic_cast<void*>(WILDCARD))
		{ that->left = left; }
	else if(left != NULL)
		{ left->replace_wildcards(that->left); }
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ that->op = op; }
	else if(op != NULL)
		{ op->replace_wildcards(that->op); }
	if(dynamic_cast<void*>(that->right) == dynamic_cast<void*>(WILDCARD))
		{ that->right = right; }
	else if(right != NULL)
		{ right->replace_wildcards(that->right); }
}

AST_expr* AST_bin_op::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_bin_op::pre_transform(Tree_transform* transform)
{
	return transform->pre_bin_op(this);
}

void AST_bin_op::transform_children(Tree_transform* transform)
{
	transform->children_bin_op(this);
}

AST_expr* AST_bin_op::post_transform(Tree_transform* transform)
{
	return transform->post_bin_op(this);
}

void AST_bin_op::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_bin_op::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_bin_op(this);
}

void AST_bin_op::visit_children(Tree_visitor* visitor)
{
	visitor->children_bin_op(this);
}

void AST_bin_op::post_visit(Tree_visitor* visitor)
{
	visitor->post_bin_op(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_conditional_expr::AST_conditional_expr()
{
}

AST_conditional_expr::AST_conditional_expr(AST_expr* cond, AST_expr* iftrue, AST_expr* iffalse)
{
	this->cond = cond;
	this->iftrue = iftrue;
	this->iffalse = iffalse;
}

bool AST_conditional_expr::deep_equals(Object* other)
{
	AST_conditional_expr* that = dynamic_cast<AST_conditional_expr*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(cond == NULL)
		{ if(that->cond != NULL) return false; }
	else
		{ if(!cond->deep_equals(that->cond)) return false; }
	if(iftrue == NULL)
		{ if(that->iftrue != NULL) return false; }
	else
		{ if(!iftrue->deep_equals(that->iftrue)) return false; }
	if(iffalse == NULL)
		{ if(that->iffalse != NULL) return false; }
	else
		{ if(!iffalse->deep_equals(that->iffalse)) return false; }
	
	return true;
}

AST_conditional_expr* AST_conditional_expr::deep_clone(Object* partial_result)
{
	AST_conditional_expr* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_conditional_expr*>(partial_result);
	else
		clone = new AST_conditional_expr();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(cond)
		clone->cond = cond->deep_clone();
	else
		clone->cond = NULL;
	assert(!cond || clone->cond);
	
	if(iftrue)
		clone->iftrue = iftrue->deep_clone();
	else
		clone->iftrue = NULL;
	assert(!iftrue || clone->iftrue);
	
	if(iffalse)
		clone->iffalse = iffalse->deep_clone();
	else
		clone->iffalse = NULL;
	assert(!iffalse || clone->iffalse);
	
	return clone;
}

bool AST_conditional_expr::try_match(Object* pattern)
{
	AST_conditional_expr* that = dynamic_cast<AST_conditional_expr*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->cond) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(cond == NULL)
		{ if(that->cond != NULL) return false; }
	else
		{ if(!cond->try_match(that->cond)) return false; }
	if(dynamic_cast<void*>(that->iftrue) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(iftrue == NULL)
		{ if(that->iftrue != NULL) return false; }
	else
		{ if(!iftrue->try_match(that->iftrue)) return false; }
	if(dynamic_cast<void*>(that->iffalse) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(iffalse == NULL)
		{ if(that->iffalse != NULL) return false; }
	else
		{ if(!iffalse->try_match(that->iffalse)) return false; }
	
	return true;
}

void AST_conditional_expr::replace_wildcards(Object* pattern)
{
	AST_conditional_expr* that = dynamic_cast<AST_conditional_expr*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->cond) == dynamic_cast<void*>(WILDCARD))
		{ that->cond = cond; }
	else if(cond != NULL)
		{ cond->replace_wildcards(that->cond); }
	if(dynamic_cast<void*>(that->iftrue) == dynamic_cast<void*>(WILDCARD))
		{ that->iftrue = iftrue; }
	else if(iftrue != NULL)
		{ iftrue->replace_wildcards(that->iftrue); }
	if(dynamic_cast<void*>(that->iffalse) == dynamic_cast<void*>(WILDCARD))
		{ that->iffalse = iffalse; }
	else if(iffalse != NULL)
		{ iffalse->replace_wildcards(that->iffalse); }
}

AST_expr* AST_conditional_expr::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_conditional_expr::pre_transform(Tree_transform* transform)
{
	return transform->pre_conditional_expr(this);
}

void AST_conditional_expr::transform_children(Tree_transform* transform)
{
	transform->children_conditional_expr(this);
}

AST_expr* AST_conditional_expr::post_transform(Tree_transform* transform)
{
	return transform->post_conditional_expr(this);
}

void AST_conditional_expr::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_conditional_expr::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_conditional_expr(this);
}

void AST_conditional_expr::visit_children(Tree_visitor* visitor)
{
	visitor->children_conditional_expr(this);
}

void AST_conditional_expr::post_visit(Tree_visitor* visitor)
{
	visitor->post_conditional_expr(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_ignore_errors::AST_ignore_errors()
{
}

AST_ignore_errors::AST_ignore_errors(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_ignore_errors::deep_equals(Object* other)
{
	AST_ignore_errors* that = dynamic_cast<AST_ignore_errors*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_ignore_errors* AST_ignore_errors::deep_clone(Object* partial_result)
{
	AST_ignore_errors* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_ignore_errors*>(partial_result);
	else
		clone = new AST_ignore_errors();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_ignore_errors::try_match(Object* pattern)
{
	AST_ignore_errors* that = dynamic_cast<AST_ignore_errors*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_ignore_errors::replace_wildcards(Object* pattern)
{
	AST_ignore_errors* that = dynamic_cast<AST_ignore_errors*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_ignore_errors::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_ignore_errors::pre_transform(Tree_transform* transform)
{
	return transform->pre_ignore_errors(this);
}

void AST_ignore_errors::transform_children(Tree_transform* transform)
{
	transform->children_ignore_errors(this);
}

AST_expr* AST_ignore_errors::post_transform(Tree_transform* transform)
{
	return transform->post_ignore_errors(this);
}

void AST_ignore_errors::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_ignore_errors::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_ignore_errors(this);
}

void AST_ignore_errors::visit_children(Tree_visitor* visitor)
{
	visitor->children_ignore_errors(this);
}

void AST_ignore_errors::post_visit(Tree_visitor* visitor)
{
	visitor->post_ignore_errors(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_constant::AST_constant()
{
}

AST_constant::AST_constant(Token_class_name* class_name, Token_constant_name* constant_name)
{
	this->class_name = class_name;
	this->constant_name = constant_name;
}

AST_constant::AST_constant(char* class_name, Token_constant_name* constant_name)
{
	this->class_name = new Token_class_name(new String(class_name));
	this->constant_name = constant_name;
}

bool AST_constant::deep_equals(Object* other)
{
	AST_constant* that = dynamic_cast<AST_constant*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	if(constant_name == NULL)
		{ if(that->constant_name != NULL) return false; }
	else
		{ if(!constant_name->deep_equals(that->constant_name)) return false; }
	
	return true;
}

AST_constant* AST_constant::deep_clone(Object* partial_result)
{
	AST_constant* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_constant*>(partial_result);
	else
		clone = new AST_constant();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	if(constant_name)
		clone->constant_name = constant_name->deep_clone();
	else
		clone->constant_name = NULL;
	assert(!constant_name || clone->constant_name);
	
	return clone;
}

bool AST_constant::try_match(Object* pattern)
{
	AST_constant* that = dynamic_cast<AST_constant*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	if(dynamic_cast<void*>(that->constant_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(constant_name == NULL)
		{ if(that->constant_name != NULL) return false; }
	else
		{ if(!constant_name->try_match(that->constant_name)) return false; }
	
	return true;
}

void AST_constant::replace_wildcards(Object* pattern)
{
	AST_constant* that = dynamic_cast<AST_constant*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
	if(dynamic_cast<void*>(that->constant_name) == dynamic_cast<void*>(WILDCARD))
		{ that->constant_name = constant_name; }
	else if(constant_name != NULL)
		{ constant_name->replace_wildcards(that->constant_name); }
}

AST_expr* AST_constant::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_constant::pre_transform(Tree_transform* transform)
{
	return transform->pre_constant(this);
}

void AST_constant::transform_children(Tree_transform* transform)
{
	transform->children_constant(this);
}

AST_expr* AST_constant::post_transform(Tree_transform* transform)
{
	return transform->post_constant(this);
}

void AST_constant::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_constant::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_constant(this);
}

void AST_constant::visit_children(Tree_visitor* visitor)
{
	visitor->children_constant(this);
}

void AST_constant::post_visit(Tree_visitor* visitor)
{
	visitor->post_constant(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_instanceof::AST_instanceof()
{
}

AST_instanceof::AST_instanceof(AST_expr* expr, AST_class_name* class_name)
{
	this->expr = expr;
	this->class_name = class_name;
}

bool AST_instanceof::deep_equals(Object* other)
{
	AST_instanceof* that = dynamic_cast<AST_instanceof*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	
	return true;
}

AST_instanceof* AST_instanceof::deep_clone(Object* partial_result)
{
	AST_instanceof* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_instanceof*>(partial_result);
	else
		clone = new AST_instanceof();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	return clone;
}

bool AST_instanceof::try_match(Object* pattern)
{
	AST_instanceof* that = dynamic_cast<AST_instanceof*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	
	return true;
}

void AST_instanceof::replace_wildcards(Object* pattern)
{
	AST_instanceof* that = dynamic_cast<AST_instanceof*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
}

AST_expr* AST_instanceof::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_instanceof::pre_transform(Tree_transform* transform)
{
	return transform->pre_instanceof(this);
}

void AST_instanceof::transform_children(Tree_transform* transform)
{
	transform->children_instanceof(this);
}

AST_expr* AST_instanceof::post_transform(Tree_transform* transform)
{
	return transform->post_instanceof(this);
}

void AST_instanceof::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_instanceof::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_instanceof(this);
}

void AST_instanceof::visit_children(Tree_visitor* visitor)
{
	visitor->children_instanceof(this);
}

void AST_instanceof::post_visit(Tree_visitor* visitor)
{
	visitor->post_instanceof(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_variable::AST_variable()
{
	init();
}

AST_variable::AST_variable(AST_target* target, AST_variable_name* variable_name, AST_expr_list* array_indices, AST_expr* string_index)
{
	init();
	this->target = target;
	this->variable_name = variable_name;
	this->array_indices = array_indices;
	this->string_index = string_index;
}

AST_variable::AST_variable(AST_variable_name* name)
{
	init();
	this->target = NULL;
	this->variable_name = name;
	this->array_indices = new AST_expr_list;
	this->string_index = NULL;
}

bool AST_variable::deep_equals(Object* other)
{
	AST_variable* that = dynamic_cast<AST_variable*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	if(!AST_list_element::deep_equals(that)) return false;
	
	if(target == NULL)
		{ if(that->target != NULL) return false; }
	else
		{ if(!target->deep_equals(that->target)) return false; }
	if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->deep_equals(that->variable_name)) return false; }
	if(array_indices == NULL)
		{ if(that->array_indices != NULL) return false; }
	else
		{ if(!array_indices->deep_equals(that->array_indices)) return false; }
	if(string_index == NULL)
		{ if(that->string_index != NULL) return false; }
	else
		{ if(!string_index->deep_equals(that->string_index)) return false; }
	
	return true;
}

AST_variable* AST_variable::deep_clone(Object* partial_result)
{
	AST_variable* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_variable*>(partial_result);
	else
		clone = new AST_variable();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	AST_list_element::deep_clone(clone);
	
	if(target)
		clone->target = target->deep_clone();
	else
		clone->target = NULL;
	assert(!target || clone->target);
	
	if(variable_name)
		clone->variable_name = variable_name->deep_clone();
	else
		clone->variable_name = NULL;
	assert(!variable_name || clone->variable_name);
	
	if(array_indices)
		clone->array_indices = array_indices->deep_clone();
	else
		clone->array_indices = NULL;
	assert(!array_indices || clone->array_indices);
	
	if(string_index)
		clone->string_index = string_index->deep_clone();
	else
		clone->string_index = NULL;
	assert(!string_index || clone->string_index);
	
	return clone;
}

bool AST_variable::try_match(Object* pattern)
{
	AST_variable* that = dynamic_cast<AST_variable*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	if(!AST_list_element::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->target) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(target == NULL)
		{ if(that->target != NULL) return false; }
	else
		{ if(!target->try_match(that->target)) return false; }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable_name == NULL)
		{ if(that->variable_name != NULL) return false; }
	else
		{ if(!variable_name->try_match(that->variable_name)) return false; }
	if(dynamic_cast<void*>(that->array_indices) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(array_indices == NULL)
		{ if(that->array_indices != NULL) return false; }
	else
		{ if(!array_indices->try_match(that->array_indices)) return false; }
	if(dynamic_cast<void*>(that->string_index) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(string_index == NULL)
		{ if(that->string_index != NULL) return false; }
	else
		{ if(!string_index->try_match(that->string_index)) return false; }
	
	return true;
}

void AST_variable::replace_wildcards(Object* pattern)
{
	AST_variable* that = dynamic_cast<AST_variable*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	AST_list_element::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->target) == dynamic_cast<void*>(WILDCARD))
		{ that->target = target; }
	else if(target != NULL)
		{ target->replace_wildcards(that->target); }
	if(dynamic_cast<void*>(that->variable_name) == dynamic_cast<void*>(WILDCARD))
		{ that->variable_name = variable_name; }
	else if(variable_name != NULL)
		{ variable_name->replace_wildcards(that->variable_name); }
	if(dynamic_cast<void*>(that->array_indices) == dynamic_cast<void*>(WILDCARD))
		{ that->array_indices = array_indices; }
	else if(array_indices != NULL)
		{ array_indices->replace_wildcards(that->array_indices); }
	if(dynamic_cast<void*>(that->string_index) == dynamic_cast<void*>(WILDCARD))
		{ that->string_index = string_index; }
	else if(string_index != NULL)
		{ string_index->replace_wildcards(that->string_index); }
}

AST_variable* AST_variable::transform(Tree_transform* transform)
{
	AST_variable* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_variable* AST_variable::pre_transform(Tree_transform* transform)
{
	return transform->pre_variable(this);
}

void AST_variable::transform_children(Tree_transform* transform)
{
	transform->children_variable(this);
}

AST_variable* AST_variable::post_transform(Tree_transform* transform)
{
	return transform->post_variable(this);
}

void AST_variable::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_variable::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_list_element(this);
	visitor->pre_expr(this);
	visitor->pre_variable(this);
}

void AST_variable::visit_children(Tree_visitor* visitor)
{
	visitor->children_variable(this);
}

void AST_variable::post_visit(Tree_visitor* visitor)
{
	visitor->post_variable(this);
	visitor->post_expr(this);
	visitor->post_list_element(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

void AST_variable::init()
{
	attrs->set("phc.parser.is_ref", new Boolean(false));
	attrs->set("phc.parser.function_params", NULL);
}

AST_pre_op::AST_pre_op()
{
}

AST_pre_op::AST_pre_op(Token_op* op, AST_variable* variable)
{
	this->op = op;
	this->variable = variable;
}

AST_pre_op::AST_pre_op(AST_variable* var, char* op)
{
	this->variable = var;
	this->op = new Token_op(new String(op));
}

bool AST_pre_op::deep_equals(Object* other)
{
	AST_pre_op* that = dynamic_cast<AST_pre_op*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->deep_equals(that->op)) return false; }
	if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->deep_equals(that->variable)) return false; }
	
	return true;
}

AST_pre_op* AST_pre_op::deep_clone(Object* partial_result)
{
	AST_pre_op* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_pre_op*>(partial_result);
	else
		clone = new AST_pre_op();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(op)
		clone->op = op->deep_clone();
	else
		clone->op = NULL;
	assert(!op || clone->op);
	
	if(variable)
		clone->variable = variable->deep_clone();
	else
		clone->variable = NULL;
	assert(!variable || clone->variable);
	
	return clone;
}

bool AST_pre_op::try_match(Object* pattern)
{
	AST_pre_op* that = dynamic_cast<AST_pre_op*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->try_match(that->op)) return false; }
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->try_match(that->variable)) return false; }
	
	return true;
}

void AST_pre_op::replace_wildcards(Object* pattern)
{
	AST_pre_op* that = dynamic_cast<AST_pre_op*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ that->op = op; }
	else if(op != NULL)
		{ op->replace_wildcards(that->op); }
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ that->variable = variable; }
	else if(variable != NULL)
		{ variable->replace_wildcards(that->variable); }
}

AST_expr* AST_pre_op::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_pre_op::pre_transform(Tree_transform* transform)
{
	return transform->pre_pre_op(this);
}

void AST_pre_op::transform_children(Tree_transform* transform)
{
	transform->children_pre_op(this);
}

AST_expr* AST_pre_op::post_transform(Tree_transform* transform)
{
	return transform->post_pre_op(this);
}

void AST_pre_op::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_pre_op::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_pre_op(this);
}

void AST_pre_op::visit_children(Tree_visitor* visitor)
{
	visitor->children_pre_op(this);
}

void AST_pre_op::post_visit(Tree_visitor* visitor)
{
	visitor->post_pre_op(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_post_op::AST_post_op()
{
}

AST_post_op::AST_post_op(AST_variable* variable, Token_op* op)
{
	this->variable = variable;
	this->op = op;
}

AST_post_op::AST_post_op(AST_variable* var, char* op)
{
	this->variable = var;
	this->op = new Token_op(new String(op));
}

bool AST_post_op::deep_equals(Object* other)
{
	AST_post_op* that = dynamic_cast<AST_post_op*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->deep_equals(that->variable)) return false; }
	if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->deep_equals(that->op)) return false; }
	
	return true;
}

AST_post_op* AST_post_op::deep_clone(Object* partial_result)
{
	AST_post_op* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_post_op*>(partial_result);
	else
		clone = new AST_post_op();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(variable)
		clone->variable = variable->deep_clone();
	else
		clone->variable = NULL;
	assert(!variable || clone->variable);
	
	if(op)
		clone->op = op->deep_clone();
	else
		clone->op = NULL;
	assert(!op || clone->op);
	
	return clone;
}

bool AST_post_op::try_match(Object* pattern)
{
	AST_post_op* that = dynamic_cast<AST_post_op*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(variable == NULL)
		{ if(that->variable != NULL) return false; }
	else
		{ if(!variable->try_match(that->variable)) return false; }
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(op == NULL)
		{ if(that->op != NULL) return false; }
	else
		{ if(!op->try_match(that->op)) return false; }
	
	return true;
}

void AST_post_op::replace_wildcards(Object* pattern)
{
	AST_post_op* that = dynamic_cast<AST_post_op*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->variable) == dynamic_cast<void*>(WILDCARD))
		{ that->variable = variable; }
	else if(variable != NULL)
		{ variable->replace_wildcards(that->variable); }
	if(dynamic_cast<void*>(that->op) == dynamic_cast<void*>(WILDCARD))
		{ that->op = op; }
	else if(op != NULL)
		{ op->replace_wildcards(that->op); }
}

AST_expr* AST_post_op::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_post_op::pre_transform(Tree_transform* transform)
{
	return transform->pre_post_op(this);
}

void AST_post_op::transform_children(Tree_transform* transform)
{
	transform->children_post_op(this);
}

AST_expr* AST_post_op::post_transform(Tree_transform* transform)
{
	return transform->post_post_op(this);
}

void AST_post_op::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_post_op::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_post_op(this);
}

void AST_post_op::visit_children(Tree_visitor* visitor)
{
	visitor->children_post_op(this);
}

void AST_post_op::post_visit(Tree_visitor* visitor)
{
	visitor->post_post_op(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_array::AST_array()
{
}

AST_array::AST_array(AST_array_elem_list* array_elems)
{
	this->array_elems = array_elems;
}

bool AST_array::deep_equals(Object* other)
{
	AST_array* that = dynamic_cast<AST_array*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(array_elems == NULL)
		{ if(that->array_elems != NULL) return false; }
	else
		{ if(!array_elems->deep_equals(that->array_elems)) return false; }
	
	return true;
}

AST_array* AST_array::deep_clone(Object* partial_result)
{
	AST_array* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_array*>(partial_result);
	else
		clone = new AST_array();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(array_elems)
		clone->array_elems = array_elems->deep_clone();
	else
		clone->array_elems = NULL;
	assert(!array_elems || clone->array_elems);
	
	return clone;
}

bool AST_array::try_match(Object* pattern)
{
	AST_array* that = dynamic_cast<AST_array*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->array_elems) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(array_elems == NULL)
		{ if(that->array_elems != NULL) return false; }
	else
		{ if(!array_elems->try_match(that->array_elems)) return false; }
	
	return true;
}

void AST_array::replace_wildcards(Object* pattern)
{
	AST_array* that = dynamic_cast<AST_array*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->array_elems) == dynamic_cast<void*>(WILDCARD))
		{ that->array_elems = array_elems; }
	else if(array_elems != NULL)
		{ array_elems->replace_wildcards(that->array_elems); }
}

AST_expr* AST_array::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_array::pre_transform(Tree_transform* transform)
{
	return transform->pre_array(this);
}

void AST_array::transform_children(Tree_transform* transform)
{
	transform->children_array(this);
}

AST_expr* AST_array::post_transform(Tree_transform* transform)
{
	return transform->post_array(this);
}

void AST_array::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_array::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_array(this);
}

void AST_array::visit_children(Tree_visitor* visitor)
{
	visitor->children_array(this);
}

void AST_array::post_visit(Tree_visitor* visitor)
{
	visitor->post_array(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_method_invocation::AST_method_invocation()
{
}

AST_method_invocation::AST_method_invocation(AST_target* target, AST_method_name* method_name, AST_actual_parameter_list* actual_parameters)
{
	this->target = target;
	this->method_name = method_name;
	this->actual_parameters = actual_parameters;
}

AST_method_invocation::AST_method_invocation(const char* name, AST_expr* arg)
{
	// This leaves the tree in an inconsistent state
	this->target = NULL;
	this->method_name = new Token_method_name(new String(name));
	this->actual_parameters = new AST_actual_parameter_list;
	this->actual_parameters->push_back(new AST_actual_parameter(false, arg));
}

AST_method_invocation::AST_method_invocation(Token_method_name* name, AST_expr* arg)
{
	this->target = NULL;
	this->method_name = name;
	this->actual_parameters = new AST_actual_parameter_list;
	this->actual_parameters->push_back(new AST_actual_parameter(false, arg));
}

AST_method_invocation::AST_method_invocation(const char* target, const char* name, AST_expr* arg)
{
	this->target = new Token_class_name(new String(target));
	this->method_name = new Token_method_name(new String(name));
	this->actual_parameters = new AST_actual_parameter_list;
	this->actual_parameters->push_back(new AST_actual_parameter(false, arg));
}

bool AST_method_invocation::deep_equals(Object* other)
{
	AST_method_invocation* that = dynamic_cast<AST_method_invocation*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(target == NULL)
		{ if(that->target != NULL) return false; }
	else
		{ if(!target->deep_equals(that->target)) return false; }
	if(method_name == NULL)
		{ if(that->method_name != NULL) return false; }
	else
		{ if(!method_name->deep_equals(that->method_name)) return false; }
	if(actual_parameters == NULL)
		{ if(that->actual_parameters != NULL) return false; }
	else
		{ if(!actual_parameters->deep_equals(that->actual_parameters)) return false; }
	
	return true;
}

AST_method_invocation* AST_method_invocation::deep_clone(Object* partial_result)
{
	AST_method_invocation* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_method_invocation*>(partial_result);
	else
		clone = new AST_method_invocation();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(target)
		clone->target = target->deep_clone();
	else
		clone->target = NULL;
	assert(!target || clone->target);
	
	if(method_name)
		clone->method_name = method_name->deep_clone();
	else
		clone->method_name = NULL;
	assert(!method_name || clone->method_name);
	
	if(actual_parameters)
		clone->actual_parameters = actual_parameters->deep_clone();
	else
		clone->actual_parameters = NULL;
	assert(!actual_parameters || clone->actual_parameters);
	
	return clone;
}

bool AST_method_invocation::try_match(Object* pattern)
{
	AST_method_invocation* that = dynamic_cast<AST_method_invocation*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->target) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(target == NULL)
		{ if(that->target != NULL) return false; }
	else
		{ if(!target->try_match(that->target)) return false; }
	if(dynamic_cast<void*>(that->method_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(method_name == NULL)
		{ if(that->method_name != NULL) return false; }
	else
		{ if(!method_name->try_match(that->method_name)) return false; }
	if(dynamic_cast<void*>(that->actual_parameters) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(actual_parameters == NULL)
		{ if(that->actual_parameters != NULL) return false; }
	else
		{ if(!actual_parameters->try_match(that->actual_parameters)) return false; }
	
	return true;
}

void AST_method_invocation::replace_wildcards(Object* pattern)
{
	AST_method_invocation* that = dynamic_cast<AST_method_invocation*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->target) == dynamic_cast<void*>(WILDCARD))
		{ that->target = target; }
	else if(target != NULL)
		{ target->replace_wildcards(that->target); }
	if(dynamic_cast<void*>(that->method_name) == dynamic_cast<void*>(WILDCARD))
		{ that->method_name = method_name; }
	else if(method_name != NULL)
		{ method_name->replace_wildcards(that->method_name); }
	if(dynamic_cast<void*>(that->actual_parameters) == dynamic_cast<void*>(WILDCARD))
		{ that->actual_parameters = actual_parameters; }
	else if(actual_parameters != NULL)
		{ actual_parameters->replace_wildcards(that->actual_parameters); }
}

AST_expr* AST_method_invocation::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_method_invocation::pre_transform(Tree_transform* transform)
{
	return transform->pre_method_invocation(this);
}

void AST_method_invocation::transform_children(Tree_transform* transform)
{
	transform->children_method_invocation(this);
}

AST_expr* AST_method_invocation::post_transform(Tree_transform* transform)
{
	return transform->post_method_invocation(this);
}

void AST_method_invocation::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_method_invocation::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_method_invocation(this);
}

void AST_method_invocation::visit_children(Tree_visitor* visitor)
{
	visitor->children_method_invocation(this);
}

void AST_method_invocation::post_visit(Tree_visitor* visitor)
{
	visitor->post_method_invocation(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_new::AST_new()
{
}

AST_new::AST_new(AST_class_name* class_name, AST_actual_parameter_list* actual_parameters)
{
	this->class_name = class_name;
	this->actual_parameters = actual_parameters;
}

bool AST_new::deep_equals(Object* other)
{
	AST_new* that = dynamic_cast<AST_new*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->deep_equals(that->class_name)) return false; }
	if(actual_parameters == NULL)
		{ if(that->actual_parameters != NULL) return false; }
	else
		{ if(!actual_parameters->deep_equals(that->actual_parameters)) return false; }
	
	return true;
}

AST_new* AST_new::deep_clone(Object* partial_result)
{
	AST_new* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_new*>(partial_result);
	else
		clone = new AST_new();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(class_name)
		clone->class_name = class_name->deep_clone();
	else
		clone->class_name = NULL;
	assert(!class_name || clone->class_name);
	
	if(actual_parameters)
		clone->actual_parameters = actual_parameters->deep_clone();
	else
		clone->actual_parameters = NULL;
	assert(!actual_parameters || clone->actual_parameters);
	
	return clone;
}

bool AST_new::try_match(Object* pattern)
{
	AST_new* that = dynamic_cast<AST_new*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(class_name == NULL)
		{ if(that->class_name != NULL) return false; }
	else
		{ if(!class_name->try_match(that->class_name)) return false; }
	if(dynamic_cast<void*>(that->actual_parameters) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(actual_parameters == NULL)
		{ if(that->actual_parameters != NULL) return false; }
	else
		{ if(!actual_parameters->try_match(that->actual_parameters)) return false; }
	
	return true;
}

void AST_new::replace_wildcards(Object* pattern)
{
	AST_new* that = dynamic_cast<AST_new*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->class_name) == dynamic_cast<void*>(WILDCARD))
		{ that->class_name = class_name; }
	else if(class_name != NULL)
		{ class_name->replace_wildcards(that->class_name); }
	if(dynamic_cast<void*>(that->actual_parameters) == dynamic_cast<void*>(WILDCARD))
		{ that->actual_parameters = actual_parameters; }
	else if(actual_parameters != NULL)
		{ actual_parameters->replace_wildcards(that->actual_parameters); }
}

AST_expr* AST_new::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_new::pre_transform(Tree_transform* transform)
{
	return transform->pre_new(this);
}

void AST_new::transform_children(Tree_transform* transform)
{
	transform->children_new(this);
}

AST_expr* AST_new::post_transform(Tree_transform* transform)
{
	return transform->post_new(this);
}

void AST_new::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_new::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_new(this);
}

void AST_new::visit_children(Tree_visitor* visitor)
{
	visitor->children_new(this);
}

void AST_new::post_visit(Tree_visitor* visitor)
{
	visitor->post_new(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

AST_clone::AST_clone()
{
}

AST_clone::AST_clone(AST_expr* expr)
{
	this->expr = expr;
}

bool AST_clone::deep_equals(Object* other)
{
	AST_clone* that = dynamic_cast<AST_clone*>(other);
	if(!that) return false;
	
	if(!AST_expr::deep_equals(that)) return false;
	
	if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->deep_equals(that->expr)) return false; }
	
	return true;
}

AST_clone* AST_clone::deep_clone(Object* partial_result)
{
	AST_clone* clone;
	
	if(partial_result)
		clone = dynamic_cast<AST_clone*>(partial_result);
	else
		clone = new AST_clone();
	assert(clone);
	
	AST_expr::deep_clone(clone);
	
	if(expr)
		clone->expr = expr->deep_clone();
	else
		clone->expr = NULL;
	assert(!expr || clone->expr);
	
	return clone;
}

bool AST_clone::try_match(Object* pattern)
{
	AST_clone* that = dynamic_cast<AST_clone*>(pattern);
	if(!that) return false;
	
	if(!AST_expr::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(expr == NULL)
		{ if(that->expr != NULL) return false; }
	else
		{ if(!expr->try_match(that->expr)) return false; }
	
	return true;
}

void AST_clone::replace_wildcards(Object* pattern)
{
	AST_clone* that = dynamic_cast<AST_clone*>(pattern);
	assert(that);
	
	AST_expr::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->expr) == dynamic_cast<void*>(WILDCARD))
		{ that->expr = expr; }
	else if(expr != NULL)
		{ expr->replace_wildcards(that->expr); }
}

AST_expr* AST_clone::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* AST_clone::pre_transform(Tree_transform* transform)
{
	return transform->pre_clone(this);
}

void AST_clone::transform_children(Tree_transform* transform)
{
	transform->children_clone(this);
}

AST_expr* AST_clone::post_transform(Tree_transform* transform)
{
	return transform->post_clone(this);
}

void AST_clone::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void AST_clone::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_clone(this);
}

void AST_clone::visit_children(Tree_visitor* visitor)
{
	visitor->children_clone(this);
}

void AST_clone::post_visit(Tree_visitor* visitor)
{
	visitor->post_clone(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

Token_int::Token_int()
{
}

Token_int::Token_int(int value, String* source_rep)
{
	this->value = value;
	this->source_rep = source_rep;
}

bool Token_int::deep_equals(Object* other)
{
	Token_int* that = dynamic_cast<Token_int*>(other);
	if(!that) return false;
	
	if(!AST_literal::deep_equals(that)) return false;
	
	if(value != that->value) return false;
	if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->deep_equals(that->source_rep)) return false; }
	
	return true;
}

Token_int* Token_int::deep_clone(Object* partial_result)
{
	Token_int* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_int*>(partial_result);
	else
		clone = new Token_int();
	assert(clone);
	
	AST_literal::deep_clone(clone);
	
	clone->value = value;
	
	if(source_rep)
		clone->source_rep = source_rep->deep_clone();
	else
		clone->source_rep = NULL;
	assert(!source_rep || clone->source_rep);
	
	return clone;
}

bool Token_int::try_match(Object* pattern)
{
	Token_int* that = dynamic_cast<Token_int*>(pattern);
	if(!that) return false;
	
	if(!AST_literal::try_match(that)) return false;
	
	if(value != that->value) return false;
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->try_match(that->source_rep)) return false; }
	
	return true;
}

void Token_int::replace_wildcards(Object* pattern)
{
	Token_int* that = dynamic_cast<Token_int*>(pattern);
	assert(that);
	
	AST_literal::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ that->source_rep = source_rep; }
	else if(source_rep != NULL)
		{ source_rep->replace_wildcards(that->source_rep); }
}

String* Token_int::get_source_rep()
{
	return source_rep;
}

AST_expr* Token_int::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* Token_int::pre_transform(Tree_transform* transform)
{
	return transform->pre_int(this);
}

void Token_int::transform_children(Tree_transform* transform)
{
	transform->children_int(this);
}

AST_expr* Token_int::post_transform(Tree_transform* transform)
{
	return transform->post_int(this);
}

void Token_int::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_int::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_literal(this);
	visitor->pre_int(this);
}

void Token_int::visit_children(Tree_visitor* visitor)
{
	visitor->children_int(this);
}

void Token_int::post_visit(Tree_visitor* visitor)
{
	visitor->post_int(this);
	visitor->post_literal(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

String* Token_int::get_value_as_string()
{
	std::ostringstream os;
	os << value;
	return new String(os.str());
}

Token_real::Token_real()
{
}

Token_real::Token_real(double value, String* source_rep)
{
	this->value = value;
	this->source_rep = source_rep;
}

bool Token_real::deep_equals(Object* other)
{
	Token_real* that = dynamic_cast<Token_real*>(other);
	if(!that) return false;
	
	if(!AST_literal::deep_equals(that)) return false;
	
	if(value != that->value) return false;
	if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->deep_equals(that->source_rep)) return false; }
	
	return true;
}

Token_real* Token_real::deep_clone(Object* partial_result)
{
	Token_real* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_real*>(partial_result);
	else
		clone = new Token_real();
	assert(clone);
	
	AST_literal::deep_clone(clone);
	
	clone->value = value;
	
	if(source_rep)
		clone->source_rep = source_rep->deep_clone();
	else
		clone->source_rep = NULL;
	assert(!source_rep || clone->source_rep);
	
	return clone;
}

bool Token_real::try_match(Object* pattern)
{
	Token_real* that = dynamic_cast<Token_real*>(pattern);
	if(!that) return false;
	
	if(!AST_literal::try_match(that)) return false;
	
	if(value != that->value) return false;
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->try_match(that->source_rep)) return false; }
	
	return true;
}

void Token_real::replace_wildcards(Object* pattern)
{
	Token_real* that = dynamic_cast<Token_real*>(pattern);
	assert(that);
	
	AST_literal::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ that->source_rep = source_rep; }
	else if(source_rep != NULL)
		{ source_rep->replace_wildcards(that->source_rep); }
}

String* Token_real::get_source_rep()
{
	return source_rep;
}

AST_expr* Token_real::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* Token_real::pre_transform(Tree_transform* transform)
{
	return transform->pre_real(this);
}

void Token_real::transform_children(Tree_transform* transform)
{
	transform->children_real(this);
}

AST_expr* Token_real::post_transform(Tree_transform* transform)
{
	return transform->post_real(this);
}

void Token_real::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_real::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_literal(this);
	visitor->pre_real(this);
}

void Token_real::visit_children(Tree_visitor* visitor)
{
	visitor->children_real(this);
}

void Token_real::post_visit(Tree_visitor* visitor)
{
	visitor->post_real(this);
	visitor->post_literal(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

String* Token_real::get_value_as_string()
{
	std::ostringstream os;
	// setprecision(20) outputs as many digits as required, with
	// a maximum of 20
	os << setprecision(20) << value;
	// unfortunately, that means that if no digits are required at
	// all (after the decimal point), the decimal point is left out
	// completely; setting the "showpoint" flag fixes this, but then
	// the STL _always_ shows all 20 digits, which is not what we
	// want either. Hence, we insert the ".0" manually if necessary:
	string str = os.str();
	if(str.find('.') >= str.size())
	str.append(".0");
	
	return new String(str);
}

Token_string::Token_string()
{
}

Token_string::Token_string(String* value, String* source_rep)
{
	this->value = value;
	this->source_rep = source_rep;
}

bool Token_string::deep_equals(Object* other)
{
	Token_string* that = dynamic_cast<Token_string*>(other);
	if(!that) return false;
	
	if(!AST_literal::deep_equals(that)) return false;
	
	if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->deep_equals(that->value)) return false; }
	if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->deep_equals(that->source_rep)) return false; }
	
	return true;
}

Token_string* Token_string::deep_clone(Object* partial_result)
{
	Token_string* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_string*>(partial_result);
	else
		clone = new Token_string();
	assert(clone);
	
	AST_literal::deep_clone(clone);
	
	if(value)
		clone->value = value->deep_clone();
	else
		clone->value = NULL;
	assert(!value || clone->value);
	
	if(source_rep)
		clone->source_rep = source_rep->deep_clone();
	else
		clone->source_rep = NULL;
	assert(!source_rep || clone->source_rep);
	
	return clone;
}

bool Token_string::try_match(Object* pattern)
{
	Token_string* that = dynamic_cast<Token_string*>(pattern);
	if(!that) return false;
	
	if(!AST_literal::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(value == NULL)
		{ if(that->value != NULL) return false; }
	else
		{ if(!value->try_match(that->value)) return false; }
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->try_match(that->source_rep)) return false; }
	
	return true;
}

void Token_string::replace_wildcards(Object* pattern)
{
	Token_string* that = dynamic_cast<Token_string*>(pattern);
	assert(that);
	
	AST_literal::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->value) == dynamic_cast<void*>(WILDCARD))
		{ that->value = value; }
	else if(value != NULL)
		{ value->replace_wildcards(that->value); }
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ that->source_rep = source_rep; }
	else if(source_rep != NULL)
		{ source_rep->replace_wildcards(that->source_rep); }
}

String* Token_string::get_source_rep()
{
	return source_rep;
}

AST_expr* Token_string::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* Token_string::pre_transform(Tree_transform* transform)
{
	return transform->pre_string(this);
}

void Token_string::transform_children(Tree_transform* transform)
{
	transform->children_string(this);
}

AST_expr* Token_string::post_transform(Tree_transform* transform)
{
	return transform->post_string(this);
}

void Token_string::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_string::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_literal(this);
	visitor->pre_string(this);
}

void Token_string::visit_children(Tree_visitor* visitor)
{
	visitor->children_string(this);
}

void Token_string::post_visit(Tree_visitor* visitor)
{
	visitor->post_string(this);
	visitor->post_literal(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

String* Token_string::get_value_as_string()
{
	return value;
}

Token_bool::Token_bool()
{
}

Token_bool::Token_bool(bool value, String* source_rep)
{
	this->value = value;
	this->source_rep = source_rep;
}

bool Token_bool::deep_equals(Object* other)
{
	Token_bool* that = dynamic_cast<Token_bool*>(other);
	if(!that) return false;
	
	if(!AST_literal::deep_equals(that)) return false;
	
	if(value != that->value) return false;
	if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->deep_equals(that->source_rep)) return false; }
	
	return true;
}

Token_bool* Token_bool::deep_clone(Object* partial_result)
{
	Token_bool* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_bool*>(partial_result);
	else
		clone = new Token_bool();
	assert(clone);
	
	AST_literal::deep_clone(clone);
	
	clone->value = value;
	
	if(source_rep)
		clone->source_rep = source_rep->deep_clone();
	else
		clone->source_rep = NULL;
	assert(!source_rep || clone->source_rep);
	
	return clone;
}

bool Token_bool::try_match(Object* pattern)
{
	Token_bool* that = dynamic_cast<Token_bool*>(pattern);
	if(!that) return false;
	
	if(!AST_literal::try_match(that)) return false;
	
	if(value != that->value) return false;
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->try_match(that->source_rep)) return false; }
	
	return true;
}

void Token_bool::replace_wildcards(Object* pattern)
{
	Token_bool* that = dynamic_cast<Token_bool*>(pattern);
	assert(that);
	
	AST_literal::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ that->source_rep = source_rep; }
	else if(source_rep != NULL)
		{ source_rep->replace_wildcards(that->source_rep); }
}

String* Token_bool::get_source_rep()
{
	return source_rep;
}

AST_expr* Token_bool::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* Token_bool::pre_transform(Tree_transform* transform)
{
	return transform->pre_bool(this);
}

void Token_bool::transform_children(Tree_transform* transform)
{
	transform->children_bool(this);
}

AST_expr* Token_bool::post_transform(Tree_transform* transform)
{
	return transform->post_bool(this);
}

void Token_bool::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_bool::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_literal(this);
	visitor->pre_bool(this);
}

void Token_bool::visit_children(Tree_visitor* visitor)
{
	visitor->children_bool(this);
}

void Token_bool::post_visit(Tree_visitor* visitor)
{
	visitor->post_bool(this);
	visitor->post_literal(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

String* Token_bool::get_value_as_string()
{
	if(value)
	return new String("True");
	else
	return new String("False");
}

Token_null::Token_null()
{
}

Token_null::Token_null(String* source_rep)
{
	this->source_rep = source_rep;
}

bool Token_null::deep_equals(Object* other)
{
	Token_null* that = dynamic_cast<Token_null*>(other);
	if(!that) return false;
	
	if(!AST_literal::deep_equals(that)) return false;
	
	if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->deep_equals(that->source_rep)) return false; }
	
	return true;
}

Token_null* Token_null::deep_clone(Object* partial_result)
{
	Token_null* clone;
	
	if(partial_result)
		clone = dynamic_cast<Token_null*>(partial_result);
	else
		clone = new Token_null();
	assert(clone);
	
	AST_literal::deep_clone(clone);
	
	if(source_rep)
		clone->source_rep = source_rep->deep_clone();
	else
		clone->source_rep = NULL;
	assert(!source_rep || clone->source_rep);
	
	return clone;
}

bool Token_null::try_match(Object* pattern)
{
	Token_null* that = dynamic_cast<Token_null*>(pattern);
	if(!that) return false;
	
	if(!AST_literal::try_match(that)) return false;
	
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ /* ignore */ }
	else if(source_rep == NULL)
		{ if(that->source_rep != NULL) return false; }
	else
		{ if(!source_rep->try_match(that->source_rep)) return false; }
	
	return true;
}

void Token_null::replace_wildcards(Object* pattern)
{
	Token_null* that = dynamic_cast<Token_null*>(pattern);
	assert(that);
	
	AST_literal::replace_wildcards(that);
	
	if(dynamic_cast<void*>(that->source_rep) == dynamic_cast<void*>(WILDCARD))
		{ that->source_rep = source_rep; }
	else if(source_rep != NULL)
		{ source_rep->replace_wildcards(that->source_rep); }
}

String* Token_null::get_source_rep()
{
	return source_rep;
}

AST_expr* Token_null::transform(Tree_transform* transform)
{
	AST_expr* node = pre_transform(transform);
	node->transform_children(transform);
	return node->post_transform(transform);
}

AST_expr* Token_null::pre_transform(Tree_transform* transform)
{
	return transform->pre_null(this);
}

void Token_null::transform_children(Tree_transform* transform)
{
	transform->children_null(this);
}

AST_expr* Token_null::post_transform(Tree_transform* transform)
{
	return transform->post_null(this);
}

void Token_null::visit(Tree_visitor* visitor)
{
	pre_visit(visitor);
	visit_children(visitor);
	post_visit(visitor);
}

void Token_null::pre_visit(Tree_visitor* visitor)
{
	visitor->pre_node(this);
	visitor->pre_target(this);
	visitor->pre_expr(this);
	visitor->pre_literal(this);
	visitor->pre_null(this);
}

void Token_null::visit_children(Tree_visitor* visitor)
{
	visitor->children_null(this);
}

void Token_null::post_visit(Tree_visitor* visitor)
{
	visitor->post_null(this);
	visitor->post_literal(this);
	visitor->post_expr(this);
	visitor->post_target(this);
	visitor->post_node(this);
}

String* Token_null::get_value_as_string()
{
	return new String("NULL");
}

void Wildcard::visit(Tree_visitor* visitor)
{
	cout << "Invalid call to 'visit' on a wildcard object!" << endl;
	assert(false);
}

void Wildcard::pre_visit(Tree_visitor* visitor)
{
	cout << "Invalid call to 'pre_visit' on a wildcard object!" << endl;
	assert(false);
}

void Wildcard::visit_children(Tree_visitor* visitor)
{
	cout << "Invalid call to 'visit_children' on a wildcard object!" << endl;
	assert(false);
}

void Wildcard::post_visit(Tree_visitor* visitor)
{
	cout << "Invalid call to 'post_visit' on a wildcard object!" << endl;
	assert(false);
}

Wildcard* Wildcard::transform(Tree_transform* transform)
{
	cout << "Invalid call to 'transform' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

Wildcard* Wildcard::pre_transform(Tree_transform* pre_transform)
{
	cout << "Invalid call to 'pre_transform' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

void Wildcard::transform_children(Tree_transform* transform_children)
{
	cout << "Invalid call to 'transform_children' on a wildcard object!" << endl;
	assert(false);
}

Wildcard* Wildcard::post_transform(Tree_transform* post_transform)
{
	cout << "Invalid call to 'post_transform' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

String* Wildcard::get_source_rep()
{
	cout << "Invalid call to 'get_source_rep' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

String* Wildcard::get_value_as_string()
{
	cout << "Invalid call to 'get_value_as_string' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

Wildcard* Wildcard::deep_clone(Object* partial_result)
{
	// Wildcard should not be inherited from
	assert(partial_result == NULL);
	// The only Wildcard instance is a singleton
	return this;
}

bool Wildcard::deep_equals(Object* pattern)
{
	cout << "Invalid call to 'deep_equals' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

bool Wildcard::match(Object* pattern)
{
	cout << "Invalid call to 'match' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

bool Wildcard::try_match(Object* pattern)
{
	cout << "Invalid call to 'try_match' on a wildcard object!" << endl;
	assert(false);
	return 0;
}

void Wildcard::replace_wildcards(Object* pattern)
{
	cout << "Invalid call to 'replace_wildcards' on a wildcard object!" << endl;
	assert(false);
}
