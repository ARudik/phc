<chapter id="gettingstarted">
<title>Getting Started</title>

<para>
For this introductory tutorial, we assume that you have successfully downloaded
and installed &phc, and that you know how to run it (<xref linkend="install">
and <xref linkend="runningphc">). This tutorial gets you started with using
&phc to develop your own tools for PHP by writing plugins.
</para>

<section>
<title>Compiling a Plugin</title>

<para> To get up and running, we'll first write a &ldquo;hello world&rdquo;
plugin that does nothing except print a string. Create a new directory, say
<Filename>~/myplugins</Filename> and create a new file
<Filename>helloworld.cpp</Filename>: </para>

<programlisting>
<token>#include</token> &lt;phc/ast.h&gt;
<token>#include</token> &lt;iostream&gt;

<token>using namespace</token> std;

<token>extern</token> "C" <token>void</token> process_ast(AST_php_script* php_script)
{
   cout &lt;&lt; "Hello world (I'm a phc plugin!)" &lt;&lt; endl;
}
</programlisting>

<para> This is an example of a minimal plugin. Every plugin you write must
contain a <literal>process_ast</literal> method with this exact signature. To
compile the plugin, run </para>

<screen>
~/myplugins$ phc_compile_plugin helloworld.cpp
</screen>
			
<para> (<application>phc_compile_plugin</application> is a small shellscript
that makes the task of compiling plugins easier; it calls
<application>g++</application> in a platform independent way; if you're
curious, you can open it in any text editor.) Finally, run the plugin using
</para>

<screen>
~/myplugins$ phc --run helloworld.la sometest.php
</screen>

<para> (You need to pass in an input script to &phc even though our plugin does
not use it.) If that worked as expected, congratulations: you've just written
your first &phc plugin! :-) </para>

</section>

<section>
<title>About <literal>extern "C"</literal></title>

<para> You may have been wondering what the <literal>extern "C"</literal> in
the definition of <literal>process_ast</literal> is for; the reason is that
&phc uses the Unix <literal>dlopen</literal> interface to load your plugin; if
you do not declare <literal>process_ast</literal> as <literal>extern
"C"</literal>, &phc will not be able to find the <literal>process_ast</literal>
symbol in your plugin because the name of that function will have been mangled
by the C++ compiler.  Incidentally, this does not mean that you cannot write
C++ code inside <literal>process_ast</literal>.</para>

<para> If you don't understand any of that, don't worry about it: just remember
that you need to declare <literal>process_ast</literal> as <literal>extern
"C"</literal> and everything will be fine. (You don't need <literal>extern
"C"</literal> for any other functions you might define.) </para>

</section>

<section>
<title>Abstract Syntax</title>

<para> To be able to do anything useful in your plugins, you need to know how
&phc represents PHP code internally. &phc's view of PHP scripts is described by
an <emphasis>abstract grammar</emphasis>. An abstract grammar describes how the contents of a
PHP script are structured. A grammar consists of a number of rules. For
example, there is a rule in the grammar that describes how
<literal>if</literal> statements work: </para>

<programlisting>
if ::= expr <emphasis>iftrue:</emphasis>statement* <emphasis>iffalse:</emphasis>statement* ; 
</programlisting>

<para> This rules reads: &ldquo;<emphasis>An <literal>if</literal> statement consists
of an expression</emphasis> (the condition of the if-statement), <emphasis>a list of
statements called `iftrue'</emphasis> (the instructions that get executed when the
condition holds), <emphasis>and another list of statements called `iffalse'</emphasis> (the
instructions that get executed when the condition does not hold)&rdquo;. The
asterisk (<literal>*</literal>) in the rule means &ldquo;list of&rdquo;.
</para>
			
<para> As a second example, consider the rule that describes arrays in PHP.
This rule should cover things such as <literal>array()</literal>,
<literal>array("a", "b")</literal> and <literal>array(1 =&gt; "a", 2 =&gt;
"g")</literal>. Arrays are described by the following two rules.  </para>

<programlisting>
array ::= array_elem* ;
array_elem ::= <emphasis>key:</emphasis>expr? <emphasis>val:</emphasis>expr ;
</programlisting>

<para> (Actually, this is a simplification, but it will do for the moment.)
These two rules say that &ldquo;<emphasis>an array consists of a list of array
elements</emphasis>&rdquo;, and an &ldquo;<emphasis>array element has an optional expression
called `key', and a second expression called `val'</emphasis>&rdquo;. The question
mark (<literal>?</literal>) means &ldquo;optional&rdquo;. Note that the grammar
does not record the need for the keyword <literal>array</literal>, or for the
parentheses and commas.  We do not need to record these, because we already
<emphasis>know</emphasis> that we are talking about an array; all we need to know is what the
array elements are. </para>
		
</section>

<section>
<title>The Abstract Syntax Tree</title>

<para> When &phc reads a PHP script, it builds up an internal representation of
the script. This representation is known as an <emphasis>abstract syntax
tree</emphasis> (or AST for short). The structure of the AST follows directly
from the abstract grammar. For people familiar with XML, this tree can be
compared to the DOM representation of an XML script (and in fact, &phc can
output the AST as an XML document, see <xref linkend="runningphc">). </para>
			
<para> For example, consider <literal>if</literal>-statements again. An
<literal>if</literal>-statement is represented by an instance of the
<literal>AST_if</literal> class, which is (approximately) defined as follows.
</para>

<programlisting>
<token>class</token> AST_if
{
<token>public</token>:
   AST_expr* expr;
   AST_statement_list* iftrue;
   AST_statement_list* iffalse;
};
</programlisting>

<para> Thus, the name of the rule (<literal>if ::= ...</literal>) translates
into a class <literal>AST_if</literal>, and the elements on the right hand side
of the rule (<literal>expr iftrue:statement* iffalse:statement*</literal>)
correspond directly to the class members.  The class
<literal>AST_statement_list</literal> inherits from the STL
<literal>list</literal> class, and can thus be treated as such. </para>
		
<para> Similarly, the class definitions for arrays and array elements look like
</para> 
		
<programlisting>
<token>class</token> AST_array
{
<token>public</token>:
   AST_array_elem_list* array_elems;
};

<token>class</token> AST_array_elem
{
<token>public</token>:
   AST_expr* key;
   AST_expr* val;
};
</programlisting>

<para> When you start developing applications with &phc you will find it useful
to consult the full description of the grammar, which can be found in <xref
linkend="grammar">. A detailed explanation of the structure of this grammar,
and how it converts to the C++ class structure, can be found in <xref
linkend="maketeatheory">. Some notes on how &phc converts normal PHP code into
abstract syntax can be found in <xref linkend="representingphp">.  </para>

</section>

<section>
<title>Working with the AST</title>

<para> When you want to build tools based on &phc, you do not have to
understand how the abstract syntax tree is built, because this is done for you.
Once the tree has been built, you can examine or modify the tree in any way you
want. When you are finished, you can ask &phc to output the tree to normal PHP
code again. </para> 

<para> Let's write a very simple plugin that counts the number of class
definitions in a script. If you look at the <xref linkend="grammar"
endterm="grammar">, you will notice that class definitions are represented by a
(C++) class called <literal>AST_class_def</literal>. So, we need to count the
number of objects of type <literal>AST_class_def</literal> in the tree. Create
a new file <filename>~/myplugins/count_classes.cpp</filename>.  Recall the
skeleton plugin: </para>
		
<programlisting>
<token>#include</token> &lt;phc/ast.h&gt;

<token>extern</token> "C" <token>void</token> process_ast(AST_php_script* php_script)
{
}
</programlisting>

<para> You will notice that <literal>process_ast</literal> gets passed an
object of type <literal>AST_php_script</literal>. This is the top-level node of
the generated AST. If you look at the grammar (<xref linkend="grammar">), you
will find that <literal>AST_php_script</literal> corresponds to the following
rule: </para>
	
<programlisting>
php_script ::= interface_def* class_def+ ;
</programlisting>

<para> Thus, as far as &phc is concerned, a PHP script consists of a number of
interface definitions, followed by a number of class definitions (see <xref
linkend="representingphp">).  The plus (<literal>+</literal>) in this rule is
similar to an asterisk (<literal>*</literal>), but indicates that there must at
least be one item in the list. In other words, a PHP script may not have any
interface definitions, but it must have at least one class definition. </para>

<para> By now you should be able to deduce that the class
<literal>AST_php_script</literal> will have two members, called
<literal>interface_defs</literal> and <literal>class_defs</literal>, both of
which are lists. So, to count the number of classes, all we have to do is query
the number of elements in the <literal>class_defs</literal> vector: </para>

<programlisting>
<token>#include</token> &lt;phc/ast.h&gt;

<token>extern</token> "C" <token>void</token> process_ast(AST_php_script* php_script)
{
   printf("%d class definition(s) found\n", php_script->class_defs->size());
}
</programlisting>

<para> Save this file to <filename>~/myplugins/count_classes.cpp</filename>. Compile:
</para>

<programlisting>
~/myplugins$ phc_compile_plugin count_classes.cpp
</programlisting>

<para> And run: </para>

<programlisting>
./phc --run count_classes.la hello.php
</programlisting>

</section>

<section>
<title>Actually..</title>

<para> If you actually did try to run your plugin, you might think right now
that something went wrong: &phc appears to report one class definition too
many!  However, there is a very good reason for this. We said earlier that as
far as &phc is concerned, a PHP script consists of a number of interface
definitions, followed by at least one class definition. So where does the code
that is defined outside of any class go? </para>

<para> The answer is that any code defined outside any class goes into a
special class called <literal>%MAIN%</literal>. Any functions you define that
do not belong to any class, become members of <literal>%MAIN%</literal>, and
any code you write that does not belong to any function, becomes part of a
special method in <literal>%MAIN%</literal> called <literal>%run%</literal>.
When &phc outputs the tree back to normal PHP code, <literal>%MAIN%</literal>
disappears; however, when you work with the tree, there is no distinction
between code defined inside and outside classes; in the tree, everything is
defined as part of some class. This makes the tree simpler and easier to work
with. </para>

<para> More details about how the various PHP constructs are represented in the
abstract grammar can be found in <xref linkend="representingphp">. </para>

</section>

<section>
<title>Writing Stand Alone Applications</title>

<para> If you prefer not to write a plugin but want to modify &phc itself to
derive a new, stand-alone, application, you can modify
<literal>process_ast</literal> in
<filename>process_ast/process_ast.cpp</filename> in the &phc source tree
instead. This has the effect of &ldquo;hardcoding&rdquo; your plugin into &phc
(in versions before 0.1.7, this was the only way to write extensions).
However, in the rest of the tutorials we will assume that you are writing your
extension as a plugin. </para>

</section>

<section>
<title>What's Next?</title>

<para> In theory, you now know enough to start implementing your own tools for
PHP. Write a new plugin, run the plugin using the <literal>--run</literal>
option, and optionally pass in the <literal>--dump-php</literal> option also to
request that &phc outputs the tree back to PHP syntax after having executed
your plugin. </para>

<para> However, you will probably find that modifying the tree, despite being
well-defined and easy to understand, is actually rather laborious.  It requires
a lot of boring boilerplate code. The good news is that &phc provides
sophisticated support for examining and modifying this tree. This is explained
in detail in the follow-up tutorials. </para>

</section>

</chapter>
