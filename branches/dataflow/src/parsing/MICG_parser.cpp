/*
 * phc -- the open source PHP compiler
 * See doc/license/README.license for licensing information
 *
 * Parser for the Macro inline code generator.
 */

#include "MICG_parser.h"

// Uncomment to debug parsing. Useful for finding bugs in the parsed data as
// well as in the parser.
// To debug the AST structure generated by Spirit, enable BOOST_SPIRIT_DEBUG,
// and look for the final concat_match(begin) in the file.
//#define BOOST_SPIRIT_DEBUG
#define BOOST_SPIRIT_DEBUG_PRINT_SOME 80
#define BOOST_SPIRIT_DEBUG_FLAGS BOOST_SPIRIT_DEBUG_FLAGS_NODES

#include <boost/spirit.hpp>
#include <boost/spirit/tree/ast.hpp>
#include <boost/lexical_cast.hpp>
#include <iostream>
#include "lib/error.h"
#include "process_ir/debug.h"
#include "MICG.h"
#include "lib/Map.h"
#include "MICG_factory.h"

using namespace std;
using namespace boost::spirit;
using namespace boost;
using namespace MICG;


MICG_parser::MICG_parser ()
{
}



struct skip_grammar : public grammar<skip_grammar>
{
	template <typename ScannerT>
	struct definition
	{
		rule<ScannerT> skip;

		definition (skip_grammar const& self)
		{
			BOOST_SPIRIT_DEBUG_TRACE_NODE(skip, false);
			skip = no_node_d[space_p | comment_p ("//") | comment_p ("/*", "*/")];
		}

		rule<ScannerT> const& start() const
		{ 
			return skip;
		}
	};
};



/*
 * Limitations:
 *		- Its hard to put {} around the body of a template. Use @@@ instead.
 *		- Quoted strings dont support escaping of '"'. However, a quoted string
 *		is only used as a parameter to a macro, so thats not a great problem.
 */
struct MICG_grammar : public grammar<MICG_grammar>
{
	// TODO: the duplcation here is tedious
	enum 
	{
		// leave 0 to indicate no ID
		actual_parameter_list_id = 1,
		attr_name_id,
		base_expr_id,
		body_id,
		body_part_list_id,
		c_code_id,
		equals_id,
		expr_id,
		formal_parameter_id,
		formal_parameter_list_id = 10,
		interpolation_id,
		lookup_id,
		macro_call_id,
		param_name_id,
		pattern_name_id,
		quoted_string_id,
		r_id,
		_rule_id,
		_rule_list_id,
		signature_id = 20,
		_template_id,
		_template_list_id,
		type_name_id,
	};


	template <typename ScannerT>
	struct definition
	{
#define DECL_RULE(NAME) rule<ScannerT, parser_context<>, parser_tag<NAME##_id> >	NAME;
		DECL_RULE(actual_parameter_list);
		DECL_RULE(attr_name);
		DECL_RULE(base_expr);
		DECL_RULE(body);
		DECL_RULE(body_part_list);
		DECL_RULE(c_code);
		DECL_RULE(equals);
		DECL_RULE(expr);
		DECL_RULE(formal_parameter);
		DECL_RULE(formal_parameter_list);
		DECL_RULE(interpolation);
		DECL_RULE(lookup);
		DECL_RULE(macro_call);
		DECL_RULE(param_name);
		DECL_RULE(pattern_name);
		DECL_RULE(quoted_string);
		DECL_RULE(r);
		DECL_RULE(_rule);
		DECL_RULE(_rule_list);
		DECL_RULE(signature);
		DECL_RULE(_template);
		DECL_RULE(_template_list);
		DECL_RULE(type_name);


		definition (MICG_grammar const& self)
		{
			BOOST_SPIRIT_DEBUG_RULE(actual_parameter_list);
			BOOST_SPIRIT_DEBUG_RULE(attr_name);
			BOOST_SPIRIT_DEBUG_RULE(body_part_list);
			BOOST_SPIRIT_DEBUG_RULE(base_expr);
			BOOST_SPIRIT_DEBUG_RULE(body);
			BOOST_SPIRIT_DEBUG_RULE(c_code);
			BOOST_SPIRIT_DEBUG_RULE(equals);
			BOOST_SPIRIT_DEBUG_RULE(expr);
			BOOST_SPIRIT_DEBUG_RULE(formal_parameter);
			BOOST_SPIRIT_DEBUG_RULE(interpolation);
			BOOST_SPIRIT_DEBUG_RULE(lookup);
			BOOST_SPIRIT_DEBUG_RULE(macro_call);
			BOOST_SPIRIT_DEBUG_RULE(param_name);
			BOOST_SPIRIT_DEBUG_RULE(pattern_name);
			BOOST_SPIRIT_DEBUG_RULE(quoted_string);
			BOOST_SPIRIT_DEBUG_RULE(r);
			BOOST_SPIRIT_DEBUG_RULE(_rule);
			BOOST_SPIRIT_DEBUG_RULE(_rule_list);
			BOOST_SPIRIT_DEBUG_RULE(signature);
			BOOST_SPIRIT_DEBUG_RULE(_template);
			BOOST_SPIRIT_DEBUG_RULE(_template_list);
			BOOST_SPIRIT_DEBUG_RULE(type_name);

			// We separate these so that the grammar doesnt get cluttered with
			// 'no_node_p's, which say not to add the nodinto the AST.

			pattern_name = lexeme_d[leaf_node_d[+(alpha_p | '_')]];
			type_name = lexeme_d[leaf_node_d[+lower_p]];
			param_name = lexeme_d[leaf_node_d[+(upper_p | '_')]];
			attr_name = lexeme_d[leaf_node_d[+(alpha_p | '_')]];
			quoted_string = lexeme_d[leaf_node_d[confix_p ('"', *anychar_p, '"')]];
			
			// A signature line
			// We separate these so that the AST is easier to put through the
			// MICG_factory.
			formal_parameter = type_name >> param_name;
			formal_parameter_list = root_node_d [list_p(formal_parameter, ',')];
			signature = pattern_name >> '(' >> formal_parameter_list >> ')';

			// A rule line
			lookup = param_name >> "." >> attr_name;
			base_expr = lookup | param_name | quoted_string;
			expr = base_expr >> !("==" >> base_expr);
			_rule = str_p("where") >> expr;
			_rule_list = *_rule;

			// Bodies
			// We don't want c_code to take in macro_call, interpolation, or @@@.
			// However, we do want to allow '$' and '\\' in c_code. So we allow
			// them as the first character only. Since we match interpolation and
			// macro_call before c_code, if C_code stops on $ and \\, it will try
			// macro_call and interpolation before it incorporates '$' and '\\'.
			c_code = lexeme_d[leaf_node_d[(anychar_p - '@') >> *(anychar_p - (ch_p('\\') | '$' | '@'))]];

			actual_parameter_list = list_p (param_name | quoted_string, ", ");
			macro_call = ('\\' >> pattern_name >> '(' >> actual_parameter_list >> ");");

			interpolation = ('$' >> param_name) | ("${" >> lookup >> '}');

			// A template
			body_part_list = *(macro_call | interpolation | c_code);
			body = "@@@" >> body_part_list >> "@@@";
			_template = signature >> _rule_list >> body;

			_template_list = *_template;
			r = _template_list;
		}

		rule<ScannerT, parser_context<>, parser_tag<r_id> > const& start() const
		{ 
			return r;
		}
	};
};

typedef char const* iterator_t;
typedef tree_match<iterator_t> match_t;
typedef match_t::tree_iterator iter_t;
typedef match_t::node_t node_t;
typedef match_t::container_t container;

/* Extract the structure from the Boost AST, and put it into the maketea MICG.
 *
 * There are 3 kinds of node:
 *		- maketea tokens: their value is available in the node
 *		- conjunctions: their contructor arguments are available as their children
 *		- syntax tokens: these have an _id of 0, and must be ignored. Although we
 *		can remove tokens from the Boost AST (by marking them with
 *		no_node_d[...]), I've left them in, as the annotations to remove them
 *		makes the grammar very unreadable.
 */

Object* create_micg_node (node_t tree);

List<Object*>* create_micg_list (container trees)
{
	List<Object*>* result = new List<Object*>;
	foreach (node_t tree, trees)
	{
		Object* obj = create_micg_node (tree);

		// Ignore syntax tokens
		if (obj == NULL)
			continue;

		result->push_back (obj);
	}

	return result;
}

/*
 * Spirit will not create empty lists, or lists of 1 element, instead producing
 * nothing, or just a single node. Hack it.
 *
 * This checks position INDEX to see if it is a T_list. If not, add empty list,
 * or, if there is a T there, wrap it in a list.
 *
 * This checks types, so it assumes that one T_list is not followed by another.
 */
template <class T>
Object_list*
check_param_list (Object_list* in, unsigned int index)
{
	// Too short. Add it in last position.
	if (index > in->size ())
	{
		assert (in->size () == index + 1);
		in->push_back (new List<T*>);
		return in;
	}

	// Check if its already perfect.
	if (isa<List<T*> > (in->at(index)))
		return in;

	Object* subject = in->at (index);
	Object_list* result = new Object_list;
	foreach (Object* obj, *in)
	{
		if (obj == subject)
		{
			// An unwrapper node: wrap it
			if (isa<T> (obj))
			{
				result->push_back (new List<T*> (dyc<T> (obj)));
				continue;
			}
			else // Empty list: add a list.
				result->push_back (new List<T*>);
		}

		result->push_back (obj);
	}
	return result;
}



Object*
create_micg_node (node_t tree)
{
	Map<long, string> names;
	names[MICG_grammar::actual_parameter_list_id] = "Actual_parameter_list";
	names[MICG_grammar::attr_name_id] = "ATTR_NAME";
	names[MICG_grammar::body_id] = "Body";
	names[MICG_grammar::body_part_list_id] = "Body_part_list";
	names[MICG_grammar::c_code_id] = "C_CODE";
	names[MICG_grammar::expr_id] = "Equals"; // Exprs only appear in the spirit AST for ==
	names[MICG_grammar::formal_parameter_id] = "Formal_parameter";
	names[MICG_grammar::formal_parameter_list_id] = "Formal_parameter_list";
	names[MICG_grammar::interpolation_id] = "Interpolation";
	names[MICG_grammar::lookup_id] = "Lookup";
	names[MICG_grammar::macro_call_id] = "Macro_call";
	names[MICG_grammar::param_name_id] = "PARAM_NAME";
	names[MICG_grammar::pattern_name_id] = "PATTERN_NAME";
	names[MICG_grammar::quoted_string_id] = "STRING";
	names[MICG_grammar::_rule_id] = "Rule";
	names[MICG_grammar::_rule_list_id] = "Rule_list";
	names[MICG_grammar::signature_id] = "Signature";
	names[MICG_grammar::_template_id] = "Template";
	names[MICG_grammar::_template_list_id] = "Template_list";
	names[MICG_grammar::type_name_id] = "TYPE";

	long id = tree.value.id ().to_long ();
	String* value = s(string (tree.value.begin(), tree.value.end()));
	DEBUG ("processing " << id << " - " << *value);
	switch (id)
	{
		/*
		 * Conjunctions 
		 */
		case MICG_grammar::actual_parameter_list_id:
		case MICG_grammar::body_id:
		case MICG_grammar::body_part_list_id:
		case MICG_grammar::expr_id:
		case MICG_grammar::formal_parameter_id:
		case MICG_grammar::formal_parameter_list_id:
		case MICG_grammar::lookup_id:
		case MICG_grammar::macro_call_id:
		case MICG_grammar::_rule_id:
		case MICG_grammar::_rule_list_id:
		case MICG_grammar::signature_id:
		case MICG_grammar::_template_id:
		case MICG_grammar::_template_list_id:
		{
			assert (*value == "");
			Object_list* params = create_micg_list (tree.children);

			// Hack for Spirit 'bug' (see comment at definition).
			if (id == MICG_grammar::_template_id)
				params = check_param_list<Rule> (params, 1);
			else if (id == MICG_grammar::signature_id)
				params = check_param_list<Formal_parameter> (params, 1);
			else if (id == MICG_grammar::body_id)
				params = check_param_list<Body_part> (params, 0);

			Object* result = Node_factory::create (names[id].c_str(), params);

			assert (result);
			if (Node* node = dynamic_cast<Node*> (result))
				node->assert_valid ();
			return result;
		}

		/* Disjunctions (ignore) */
		case MICG_grammar::interpolation_id:
		{
			Object_list* list = create_micg_list (tree.children);
			assert (list->size () == 1);
			return list->front ();
		}

		/*
		 * Tokens
		 */

		case MICG_grammar::quoted_string_id:
			// Strip off the ""s
			value = new String (value->substr (1, value->size() - 2));
			// Fallthrough

		case MICG_grammar::attr_name_id:
		case MICG_grammar::c_code_id:
		case MICG_grammar::param_name_id:
		case MICG_grammar::pattern_name_id:
		case MICG_grammar::type_name_id:
		{
			assert (*value != "");
			Object* result = Node_factory::create (
					names[id].c_str(),
					new Object_list (value));

			assert (result);
			dyc<Node> (result)->assert_valid ();
			return result;
		}


		/* Ignore syntactic tokens */
		case 0:
			return NULL;


		default:
			cerr << "havent handled node with ID: " << id << endl;
			phc_unreachable ();
	}
}


void
MICG_parser::parse (string str)
{
	// By using a phrase parser with a white-space skip, comments are ignored,
	// and we can ignore white space.

	MICG_grammar g;
	skip_grammar skipg;

	BOOST_SPIRIT_DEBUG_GRAMMAR(g);
	BOOST_SPIRIT_DEBUG_TRACE_NODE(skipg, false);

	tree_parse_info<> info = ast_parse(str.c_str(), g >> end_p, skipg);

#ifdef BOOST_SPIRIT_DEBUG
	cout
	<< "stop: " << string (info.stop).substr (0,500) << "\n"
	<< "full: " << info.full << "\n"
	<< "length: " << info.length << "\n"
	;
#endif

	if (!info.full)
		phc_internal_error ("Cannot parse template at %s", string (info.stop).substr (0,500).c_str ());

	assert (info.trees.size() == 1);
	Template_list* ts = dyc<Template_list> (create_micg_node (info.trees[0]));
}

